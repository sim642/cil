<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>GoblintCil (goblint-cil.GoblintCil)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../index.html">goblint-cil</a> &#x00BB; GoblintCil</nav><header class="odoc-preamble"><h1>Module <code><span>GoblintCil</span></code></h1><p><b>CIL API Documentation.</b></p></header><nav class="odoc-toc"><ul><li><a href="#cil-modules">CIL modules</a></li><li><a href="#frontc-modules">FrontC modules</a></li><li><a href="#utility-modules">Utility modules</a></li></ul></nav><div class="odoc-content"><div class="odoc-include"><div class="odoc-spec"><div class="spec value" id="val-initCIL" class="anchored"><a href="#val-initCIL" class="anchor"></a><code><span><span class="keyword">val</span> initCIL : <span>unit <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Call this function to perform some initialization.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cilVersion" class="anchored"><a href="#val-cilVersion" class="anchor"></a><code><span><span class="keyword">val</span> cilVersion : string</span></code></div><div class="spec-doc"><p>These are the CIL version numbers. A CIL version is a number of the form M.m.r (major, minor and release)</p></div></div><p>This module defines the abstract syntax of CIL. It also provides utility functions for traversing the CIL data structures, and pretty-printing them. The parser can be invoked as <code>Frontc.parse: string -&gt; unit -&gt;</code> <a href="#type-file"><code>file</code></a>. This function must be given the name of a preprocessed C file and will return the top-level data structure that describes a whole source file. The parsing and elaboration into CIL is done as for GCC source.</p><p><b>The Abstract Syntax of CIL</b></p><p>The top-level representation of a CIL source file (and the result of the parsing and elaboration). Its main contents is the list of global declarations and definitions. You can iterate over the globals in a <a href="#type-file"><code>file</code></a> using the following iterators: <a href="#val-mapGlobals"><code>mapGlobals</code></a>, <a href="#val-iterGlobals"><code>iterGlobals</code></a> and <a href="#val-foldGlobals"><code>foldGlobals</code></a>. You can also use the <a href="#val-dummyFile"><code>dummyFile</code></a> when you need a <a href="#type-file"><code>file</code></a> as a placeholder. For each global item CIL stores the source location where it appears (using the type <a href="#type-location"><code>location</code></a>)</p><div class="odoc-spec"><div class="spec type" id="type-file" class="anchored"><a href="#type-file" class="anchor"></a><code><span><span class="keyword">type</span> file</span><span> = </span><span>{</span></code><table><tr id="type-file.fileName" class="anchored"><td class="def record field"><a href="#type-file.fileName" class="anchor"></a><code><span><span class="keyword">mutable</span> fileName : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The complete file name</p><span class="comment-delim">*)</span></td></tr><tr id="type-file.globals" class="anchored"><td class="def record field"><a href="#type-file.globals" class="anchor"></a><code><span><span class="keyword">mutable</span> globals : <span><a href="#type-global">global</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>List of globals as they will appear in the printed file</p><span class="comment-delim">*)</span></td></tr><tr id="type-file.globinit" class="anchored"><td class="def record field"><a href="#type-file.globinit" class="anchor"></a><code><span><span class="keyword">mutable</span> globinit : <span><a href="#type-fundec">fundec</a> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An optional global initializer function. This is a function where you can put stuff that must be executed before the program is started. This function is conceptually at the end of the file, although it is not part of the globals list. Use <a href="#val-getGlobInit"><code>getGlobInit</code></a> to create/get one.</p><span class="comment-delim">*)</span></td></tr><tr id="type-file.globinitcalled" class="anchored"><td class="def record field"><a href="#type-file.globinitcalled" class="anchor"></a><code><span><span class="keyword">mutable</span> globinitcalled : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Whether the global initialization function is called in main. This should always be false if there is no global initializer. When you create a global initialization CIL will try to insert code in main to call it. This will not happen if your file does not contain a function called &quot;main&quot;</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Top-level representation of a C source file</p></div></div><div class="odoc-spec"><div class="spec type" id="type-comment" class="anchored"><a href="#type-comment" class="anchor"></a><code><span><span class="keyword">and</span> comment</span><span> = <a href="#type-location">location</a> * string</span></code></div></div><p><b>Globals</b>. The main type for representing global declarations and definitions. A list of these form a CIL file. The order of globals in the file is generally important.</p><div class="odoc-spec"><div class="spec type" id="type-global" class="anchored"><a href="#type-global" class="anchor"></a><code><span><span class="keyword">and</span> global</span><span> = </span></code><table><tr id="type-global.GType" class="anchored"><td class="def variant constructor"><a href="#type-global.GType" class="anchor"></a><code><span>| </span><span><span class="constructor">GType</span> <span class="keyword">of</span> <a href="#type-typeinfo">typeinfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A typedef. All uses of type names (through the <code>TNamed</code> constructor) must be preceded in the file by a definition of the name. The string is the defined name and always not-empty.</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GCompTag" class="anchored"><td class="def variant constructor"><a href="#type-global.GCompTag" class="anchor"></a><code><span>| </span><span><span class="constructor">GCompTag</span> <span class="keyword">of</span> <a href="#type-compinfo">compinfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Defines a struct/union tag with some fields. There must be one of these for each struct/union tag that you use (through the <code>TComp</code> constructor) since this is the only context in which the fields are printed. Consequently nested structure tag definitions must be broken into individual definitions with the innermost structure defined first.</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GCompTagDecl" class="anchored"><td class="def variant constructor"><a href="#type-global.GCompTagDecl" class="anchor"></a><code><span>| </span><span><span class="constructor">GCompTagDecl</span> <span class="keyword">of</span> <a href="#type-compinfo">compinfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Declares a struct/union tag. Use as a forward declaration. This is printed without the fields.</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GEnumTag" class="anchored"><td class="def variant constructor"><a href="#type-global.GEnumTag" class="anchor"></a><code><span>| </span><span><span class="constructor">GEnumTag</span> <span class="keyword">of</span> <a href="#type-enuminfo">enuminfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Declares an enumeration tag with some fields. There must be one of these for each enumeration tag that you use (through the <code>TEnum</code> constructor) since this is the only context in which the items are printed.</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GEnumTagDecl" class="anchored"><td class="def variant constructor"><a href="#type-global.GEnumTagDecl" class="anchor"></a><code><span>| </span><span><span class="constructor">GEnumTagDecl</span> <span class="keyword">of</span> <a href="#type-enuminfo">enuminfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Declares an enumeration tag. Use as a forward declaration. This is printed without the items.</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GVarDecl" class="anchored"><td class="def variant constructor"><a href="#type-global.GVarDecl" class="anchor"></a><code><span>| </span><span><span class="constructor">GVarDecl</span> <span class="keyword">of</span> <a href="#type-varinfo">varinfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A variable declaration (not a definition). If the variable has a function type then this is a prototype. There can be several declarations and at most one definition for a given variable. If both forms appear then they must share the same varinfo structure. A prototype shares the varinfo with the fundec of the definition. Either has storage Extern or there must be a definition in this file</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GVar" class="anchored"><td class="def variant constructor"><a href="#type-global.GVar" class="anchor"></a><code><span>| </span><span><span class="constructor">GVar</span> <span class="keyword">of</span> <a href="#type-varinfo">varinfo</a> * <a href="#type-initinfo">initinfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A variable definition. Can have an initializer. The initializer is updateable so that you can change it without requiring to recreate the list of globals. There can be at most one definition for a variable in an entire program. Cannot have storage Extern or function type. Note: the initializer field is kept for backwards compatibility, but it is now also available directly in the varinfo.</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GFun" class="anchored"><td class="def variant constructor"><a href="#type-global.GFun" class="anchor"></a><code><span>| </span><span><span class="constructor">GFun</span> <span class="keyword">of</span> <a href="#type-fundec">fundec</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A function definition.</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GAsm" class="anchored"><td class="def variant constructor"><a href="#type-global.GAsm" class="anchor"></a><code><span>| </span><span><span class="constructor">GAsm</span> <span class="keyword">of</span> string * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Global asm statement. These ones can contain only a template</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GPragma" class="anchored"><td class="def variant constructor"><a href="#type-global.GPragma" class="anchor"></a><code><span>| </span><span><span class="constructor">GPragma</span> <span class="keyword">of</span> <a href="#type-attribute">attribute</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Pragmas at top level. Use the same syntax as attributes</p><span class="comment-delim">*)</span></td></tr><tr id="type-global.GText" class="anchored"><td class="def variant constructor"><a href="#type-global.GText" class="anchor"></a><code><span>| </span><span><span class="constructor">GText</span> <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Some text (printed verbatim) at top level. E.g., this way you can put comments in the output.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>A global declaration or definition</p></div></div><p><b>Types</b>. A C type is represented in CIL using the type <a href="#type-typ"><code>typ</code></a>. Among types we differentiate the integral types (with different kinds denoting the sign and precision), floating point types, enumeration types, array and pointer types, and function types. Every type is associated with a list of attributes, which are always kept in sorted order. Use <a href="#val-addAttribute"><code>addAttribute</code></a> and <a href="#val-addAttributes"><code>addAttributes</code></a> to construct list of attributes. If you want to inspect a type, you should use <a href="#val-unrollType"><code>unrollType</code></a> or <a href="#val-unrollTypeDeep"><code>unrollTypeDeep</code></a> to see through the uses of named types.</p><p>CIL is configured at build-time with the sizes and alignments of the underlying compiler. CIL contains functions that can compute the size of a type (in bits) <a href="#val-bitsSizeOf"><code>bitsSizeOf</code></a>, the alignment of a type (in bytes) <a href="#val-alignOf_int"><code>alignOf_int</code></a>, and can convert an offset into a start and width (both in bits) using the function <a href="#val-bitsOffset"><code>bitsOffset</code></a>. At the moment these functions do not take into account the <code>packed</code> attributes and pragmas.</p><div class="odoc-spec"><div class="spec type" id="type-typ" class="anchored"><a href="#type-typ" class="anchor"></a><code><span><span class="keyword">and</span> typ</span><span> = </span></code><table><tr id="type-typ.TVoid" class="anchored"><td class="def variant constructor"><a href="#type-typ.TVoid" class="anchor"></a><code><span>| </span><span><span class="constructor">TVoid</span> <span class="keyword">of</span> <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Void type. Also predefined as <a href="#val-voidType"><code>voidType</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TInt" class="anchored"><td class="def variant constructor"><a href="#type-typ.TInt" class="anchor"></a><code><span>| </span><span><span class="constructor">TInt</span> <span class="keyword">of</span> <a href="#type-ikind">ikind</a> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An integer type. The kind specifies the sign and width. Several useful variants are predefined as <a href="#val-intType"><code>intType</code></a>, <a href="#val-uintType"><code>uintType</code></a>, <a href="#val-longType"><code>longType</code></a>, <a href="#val-charType"><code>charType</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TFloat" class="anchored"><td class="def variant constructor"><a href="#type-typ.TFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">TFloat</span> <span class="keyword">of</span> <a href="#type-fkind">fkind</a> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A floating-point type. The kind specifies the precision. You can also use the predefined constant <a href="#val-doubleType"><code>doubleType</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TPtr" class="anchored"><td class="def variant constructor"><a href="#type-typ.TPtr" class="anchor"></a><code><span>| </span><span><span class="constructor">TPtr</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Pointer type. Several useful variants are predefined as <a href="#val-charPtrType"><code>charPtrType</code></a>, <a href="#val-charConstPtrType"><code>charConstPtrType</code></a> (pointer to a constant character), <a href="#val-voidPtrType"><code>voidPtrType</code></a>, <a href="#val-intPtrType"><code>intPtrType</code></a></p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TArray" class="anchored"><td class="def variant constructor"><a href="#type-typ.TArray" class="anchor"></a><code><span>| </span><span><span class="constructor">TArray</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <span><a href="#type-exp">exp</a> option</span> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Array type. It indicates the base type and the array length.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TFun" class="anchored"><td class="def variant constructor"><a href="#type-typ.TFun" class="anchor"></a><code><span>| </span><span><span class="constructor">TFun</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <span><span><span>(string * <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a>)</span> list</span> option</span> * bool * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Function type. Indicates the type of the result, the name, type and name attributes of the formal arguments (<code>None</code> if no arguments were specified, as in a function whose definition or prototype we have not seen; <code>Some []</code> means void). Use <a href="#val-argsToList"><code>argsToList</code></a> to obtain a list of arguments. The boolean indicates if it is a variable-argument function. If this is the type of a varinfo for which we have a function declaration then the information for the formals must match that in the function's sformals. Use <a href="#val-setFormals"><code>setFormals</code></a>, or <a href="#val-setFunctionType"><code>setFunctionType</code></a>, or <a href="#val-makeFormalVar"><code>makeFormalVar</code></a> for this purpose.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TNamed" class="anchored"><td class="def variant constructor"><a href="#type-typ.TNamed" class="anchor"></a><code><span>| </span><span><span class="constructor">TNamed</span> <span class="keyword">of</span> <a href="#type-typeinfo">typeinfo</a> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The use of a named type. Each such type name must be preceded in the file by a <code>GType</code> global. This is printed as just the type name. The actual referred type is not printed here and is carried only to simplify processing. To see through a sequence of named type references, use <a href="#val-unrollType"><code>unrollType</code></a> or <a href="#val-unrollTypeDeep"><code>unrollTypeDeep</code></a>. The attributes are in addition to those given when the type name was defined.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TComp" class="anchored"><td class="def variant constructor"><a href="#type-typ.TComp" class="anchor"></a><code><span>| </span><span><span class="constructor">TComp</span> <span class="keyword">of</span> <a href="#type-compinfo">compinfo</a> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The most delicate issue for C types is that recursion that is possible by using structures and pointers. To address this issue we have a more complex representation for structured types (struct and union). Each such type is represented using the <a href="#type-compinfo"><code>compinfo</code></a> type. For each composite type the <a href="#type-compinfo"><code>compinfo</code></a> structure must be declared at top level using <code>GCompTag</code> and all references to it must share the same copy of the structure. The attributes given are those pertaining to this use of the type and are in addition to the attributes that were given at the definition of the type and which are stored in the <a href="#type-compinfo"><code>compinfo</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TEnum" class="anchored"><td class="def variant constructor"><a href="#type-typ.TEnum" class="anchor"></a><code><span>| </span><span><span class="constructor">TEnum</span> <span class="keyword">of</span> <a href="#type-enuminfo">enuminfo</a> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A reference to an enumeration type. All such references must share the enuminfo among them and with a <code>GEnumTag</code> global that precedes all uses. The attributes refer to this use of the enumeration and are in addition to the attributes of the enumeration itself, which are stored inside the enuminfo</p><span class="comment-delim">*)</span></td></tr><tr id="type-typ.TBuiltin_va_list" class="anchored"><td class="def variant constructor"><a href="#type-typ.TBuiltin_va_list" class="anchor"></a><code><span>| </span><span><span class="constructor">TBuiltin_va_list</span> <span class="keyword">of</span> <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This is the same as the gcc's type with the same name</p><span class="comment-delim">*)</span></td></tr></table></div></div><p>There are a number of functions for querying the kind of a type. These are <a href="#val-isIntegralType"><code>isIntegralType</code></a>, <a href="#val-isArithmeticType"><code>isArithmeticType</code></a>, <a href="#val-isPointerType"><code>isPointerType</code></a>, <a href="#val-isScalarType"><code>isScalarType</code></a>, <a href="#val-isFunctionType"><code>isFunctionType</code></a>, <a href="#val-isArrayType"><code>isArrayType</code></a>.</p><p>There are two easy ways to scan a type. First, you can use the <a href="#val-existsType"><code>existsType</code></a> to return a boolean answer about a type. This function is controlled by a user-provided function that is queried for each type that is used to construct the current type. The function can specify whether to terminate the scan with a boolean result or to continue the scan for the nested types.</p><p>The other method for scanning types is provided by the visitor interface (see <a href="class-type-cilVisitor/index.html"><code>cilVisitor</code></a>).</p><p>If you want to compare types (or to use them as hash-values) then you should use instead type signatures (represented as <a href="#type-typsig"><code>typsig</code></a>). These contain the same information as types but canonicalized such that simple Ocaml structural equality will tell whether two types are equal. Use <a href="#val-typeSig"><code>typeSig</code></a> to compute the signature of a type. If you want to ignore certain type attributes then use <a href="#val-typeSigWithAttrs"><code>typeSigWithAttrs</code></a>.</p><div class="odoc-spec"><div class="spec type" id="type-ikind" class="anchored"><a href="#type-ikind" class="anchor"></a><code><span><span class="keyword">and</span> ikind</span><span> = </span></code><table><tr id="type-ikind.IChar" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IChar" class="anchor"></a><code><span>| </span><span><span class="constructor">IChar</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>char</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.ISChar" class="anchored"><td class="def variant constructor"><a href="#type-ikind.ISChar" class="anchor"></a><code><span>| </span><span><span class="constructor">ISChar</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>signed char</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IUChar" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IUChar" class="anchor"></a><code><span>| </span><span><span class="constructor">IUChar</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>unsigned char</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IBool" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IBool" class="anchor"></a><code><span>| </span><span><span class="constructor">IBool</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>_Bool (C99)</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IInt" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IInt" class="anchor"></a><code><span>| </span><span><span class="constructor">IInt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>int</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IUInt" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IUInt" class="anchor"></a><code><span>| </span><span><span class="constructor">IUInt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>unsigned int</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IShort" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IShort" class="anchor"></a><code><span>| </span><span><span class="constructor">IShort</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>short</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IUShort" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IUShort" class="anchor"></a><code><span>| </span><span><span class="constructor">IUShort</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>unsigned short</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.ILong" class="anchored"><td class="def variant constructor"><a href="#type-ikind.ILong" class="anchor"></a><code><span>| </span><span><span class="constructor">ILong</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>long</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IULong" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IULong" class="anchor"></a><code><span>| </span><span><span class="constructor">IULong</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>unsigned long</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.ILongLong" class="anchored"><td class="def variant constructor"><a href="#type-ikind.ILongLong" class="anchor"></a><code><span>| </span><span><span class="constructor">ILongLong</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>long long</code> (or <code>_int64</code> on Microsoft Visual C)</p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IULongLong" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IULongLong" class="anchor"></a><code><span>| </span><span><span class="constructor">IULongLong</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>unsigned long long</code> (or <code>unsigned _int64</code> on Microsoft Visual C)</p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IInt128" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IInt128" class="anchor"></a><code><span>| </span><span><span class="constructor">IInt128</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>__int128</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-ikind.IUInt128" class="anchored"><td class="def variant constructor"><a href="#type-ikind.IUInt128" class="anchor"></a><code><span>| </span><span><span class="constructor">IUInt128</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>unsigned __int128</code></p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Various kinds of integers</p></div></div><div class="odoc-spec"><div class="spec type" id="type-fkind" class="anchored"><a href="#type-fkind" class="anchor"></a><code><span><span class="keyword">and</span> fkind</span><span> = </span></code><table><tr id="type-fkind.FFloat" class="anchored"><td class="def variant constructor"><a href="#type-fkind.FFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">FFloat</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>float</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-fkind.FDouble" class="anchored"><td class="def variant constructor"><a href="#type-fkind.FDouble" class="anchor"></a><code><span>| </span><span><span class="constructor">FDouble</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>double</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-fkind.FLongDouble" class="anchored"><td class="def variant constructor"><a href="#type-fkind.FLongDouble" class="anchor"></a><code><span>| </span><span><span class="constructor">FLongDouble</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>long double</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-fkind.FComplexFloat" class="anchored"><td class="def variant constructor"><a href="#type-fkind.FComplexFloat" class="anchor"></a><code><span>| </span><span><span class="constructor">FComplexFloat</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>float _Complex</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-fkind.FComplexDouble" class="anchored"><td class="def variant constructor"><a href="#type-fkind.FComplexDouble" class="anchor"></a><code><span>| </span><span><span class="constructor">FComplexDouble</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>double _Complex</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-fkind.FComplexLongDouble" class="anchored"><td class="def variant constructor"><a href="#type-fkind.FComplexLongDouble" class="anchor"></a><code><span>| </span><span><span class="constructor">FComplexLongDouble</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p><code>long double _Complex</code></p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Various kinds of floating-point numbers</p></div></div><p><b>Attributes.</b></p><div class="odoc-spec"><div class="spec type" id="type-attribute" class="anchored"><a href="#type-attribute" class="anchor"></a><code><span><span class="keyword">and</span> attribute</span><span> = </span></code><table><tr id="type-attribute.Attr" class="anchored"><td class="def variant constructor"><a href="#type-attribute.Attr" class="anchor"></a><code><span>| </span><span><span class="constructor">Attr</span> <span class="keyword">of</span> string * <span><a href="#type-attrparam">attrparam</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An attribute has a name and some optional parameters. The name should not start or end with underscore. When CIL parses attribute names it will strip leading and ending underscores (to ensure that the multitude of GCC attributes such as const, __const and __const__ all mean the same thing.)</p><span class="comment-delim">*)</span></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-attributes" class="anchored"><a href="#type-attributes" class="anchor"></a><code><span><span class="keyword">and</span> attributes</span><span> = <span><a href="#type-attribute">attribute</a> list</span></span></code></div><div class="spec-doc"><p>Attributes are lists sorted by the attribute name. Use the functions <a href="#val-addAttribute"><code>addAttribute</code></a> and <a href="#val-addAttributes"><code>addAttributes</code></a> to insert attributes in an attribute list and maintain the sortedness.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-attrparam" class="anchored"><a href="#type-attrparam" class="anchor"></a><code><span><span class="keyword">and</span> attrparam</span><span> = </span></code><table><tr id="type-attrparam.AInt" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AInt" class="anchor"></a><code><span>| </span><span><span class="constructor">AInt</span> <span class="keyword">of</span> int</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An integer constant</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.AStr" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AStr" class="anchor"></a><code><span>| </span><span><span class="constructor">AStr</span> <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A string constant</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.ACons" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.ACons" class="anchor"></a><code><span>| </span><span><span class="constructor">ACons</span> <span class="keyword">of</span> string * <span><a href="#type-attrparam">attrparam</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Constructed attributes. These are printed <code>foo(a1,a2,...,an)</code>. The list of parameters can be empty and in that case the parentheses are not printed.</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.ASizeOf" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.ASizeOf" class="anchor"></a><code><span>| </span><span><span class="constructor">ASizeOf</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A way to talk about types</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.ASizeOfE" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.ASizeOfE" class="anchor"></a><code><span>| </span><span><span class="constructor">ASizeOfE</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a></span></code></td></tr><tr id="type-attrparam.ASizeOfS" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.ASizeOfS" class="anchor"></a><code><span>| </span><span><span class="constructor">ASizeOfS</span> <span class="keyword">of</span> <a href="#type-typsig">typsig</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Replacement for ASizeOf in type signatures. Only used for attributes inside typsigs.</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.AAlignOf" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AAlignOf" class="anchor"></a><code><span>| </span><span><span class="constructor">AAlignOf</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code></td></tr><tr id="type-attrparam.AAlignOfE" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AAlignOfE" class="anchor"></a><code><span>| </span><span><span class="constructor">AAlignOfE</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a></span></code></td></tr><tr id="type-attrparam.AAlignOfS" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AAlignOfS" class="anchor"></a><code><span>| </span><span><span class="constructor">AAlignOfS</span> <span class="keyword">of</span> <a href="#type-typsig">typsig</a></span></code></td></tr><tr id="type-attrparam.AUnOp" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AUnOp" class="anchor"></a><code><span>| </span><span><span class="constructor">AUnOp</span> <span class="keyword">of</span> <a href="#type-unop">unop</a> * <a href="#type-attrparam">attrparam</a></span></code></td></tr><tr id="type-attrparam.ABinOp" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.ABinOp" class="anchor"></a><code><span>| </span><span><span class="constructor">ABinOp</span> <span class="keyword">of</span> <a href="#type-binop">binop</a> * <a href="#type-attrparam">attrparam</a> * <a href="#type-attrparam">attrparam</a></span></code></td></tr><tr id="type-attrparam.ADot" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.ADot" class="anchor"></a><code><span>| </span><span><span class="constructor">ADot</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a> * string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>a.foo *</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.AStar" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AStar" class="anchor"></a><code><span>| </span><span><span class="constructor">AStar</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>* a</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.AAddrOf" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AAddrOf" class="anchor"></a><code><span>| </span><span><span class="constructor">AAddrOf</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&amp; a *</p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.AIndex" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AIndex" class="anchor"></a><code><span>| </span><span><span class="constructor">AIndex</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a> * <a href="#type-attrparam">attrparam</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>a1<code>a2</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-attrparam.AQuestion" class="anchored"><td class="def variant constructor"><a href="#type-attrparam.AQuestion" class="anchor"></a><code><span>| </span><span><span class="constructor">AQuestion</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a> * <a href="#type-attrparam">attrparam</a> * <a href="#type-attrparam">attrparam</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>a1 ? a2 : a3 *</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>The type of parameters of attributes</p></div></div><p><b>Structures.</b> The <a href="#type-compinfo"><code>compinfo</code></a> describes the definition of a structure or union type. Each such <a href="#type-compinfo"><code>compinfo</code></a> must be defined at the top-level using the <code>GCompTag</code> constructor and must be shared by all references to this type (using either the <code>TComp</code> type constructor or from the definition of the fields.</p><p>If all you need is to scan the definition of each composite type once, you can do that by scanning all top-level <code>GCompTag</code>.</p><p>Constructing a <a href="#type-compinfo"><code>compinfo</code></a> can be tricky since it must contain fields that might refer to the host <a href="#type-compinfo"><code>compinfo</code></a> and furthermore the type of the field might need to refer to the <a href="#type-compinfo"><code>compinfo</code></a> for recursive types. Use the <a href="#val-mkCompInfo"><code>mkCompInfo</code></a> function to create a <a href="#type-compinfo"><code>compinfo</code></a>. You can easily fetch the <a href="#type-fieldinfo"><code>fieldinfo</code></a> for a given field in a structure with <a href="#val-getCompField"><code>getCompField</code></a>.</p><div class="odoc-spec"><div class="spec type" id="type-compinfo" class="anchored"><a href="#type-compinfo" class="anchor"></a><code><span><span class="keyword">and</span> compinfo</span><span> = </span><span>{</span></code><table><tr id="type-compinfo.cstruct" class="anchored"><td class="def record field"><a href="#type-compinfo.cstruct" class="anchor"></a><code><span><span class="keyword">mutable</span> cstruct : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>True if struct, False if union</p><span class="comment-delim">*)</span></td></tr><tr id="type-compinfo.cname" class="anchored"><td class="def record field"><a href="#type-compinfo.cname" class="anchor"></a><code><span><span class="keyword">mutable</span> cname : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The name. Always non-empty. Use <a href="#val-compFullName"><code>compFullName</code></a> to get the full name of a comp (along with the struct or union)</p><span class="comment-delim">*)</span></td></tr><tr id="type-compinfo.ckey" class="anchored"><td class="def record field"><a href="#type-compinfo.ckey" class="anchor"></a><code><span><span class="keyword">mutable</span> ckey : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A unique integer. This is assigned by <a href="#val-mkCompInfo"><code>mkCompInfo</code></a> using a global variable in the Cil module. Thus two identical structs in two different files might have different keys. Use <a href="#val-copyCompInfo"><code>copyCompInfo</code></a> to copy structures so that a new key is assigned.</p><span class="comment-delim">*)</span></td></tr><tr id="type-compinfo.cfields" class="anchored"><td class="def record field"><a href="#type-compinfo.cfields" class="anchor"></a><code><span><span class="keyword">mutable</span> cfields : <span><a href="#type-fieldinfo">fieldinfo</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Information about the fields. Notice that each fieldinfo has a pointer back to the host compinfo. This means that you should not share fieldinfo's between two compinfo's</p><span class="comment-delim">*)</span></td></tr><tr id="type-compinfo.cattr" class="anchored"><td class="def record field"><a href="#type-compinfo.cattr" class="anchor"></a><code><span><span class="keyword">mutable</span> cattr : <a href="#type-attributes">attributes</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The attributes that are defined at the same time as the composite type. These attributes can be supplemented individually at each reference to this <code>compinfo</code> using the <code>TComp</code> type constructor.</p><span class="comment-delim">*)</span></td></tr><tr id="type-compinfo.cdefined" class="anchored"><td class="def record field"><a href="#type-compinfo.cdefined" class="anchor"></a><code><span><span class="keyword">mutable</span> cdefined : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This boolean flag can be used to distinguish between structures that have not been defined and those that have been defined but have no fields (such things are allowed in gcc).</p><span class="comment-delim">*)</span></td></tr><tr id="type-compinfo.creferenced" class="anchored"><td class="def record field"><a href="#type-compinfo.creferenced" class="anchor"></a><code><span><span class="keyword">mutable</span> creferenced : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>True if used. Initially set to false.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>The definition of a structure or union type. Use <a href="#val-mkCompInfo"><code>mkCompInfo</code></a> to make one and use <a href="#val-copyCompInfo"><code>copyCompInfo</code></a> to copy one (this ensures that a new key is assigned and that the fields have the right pointers to parents.).</p></div></div><p><b>Structure fields.</b> The <a href="#type-fieldinfo"><code>fieldinfo</code></a> structure is used to describe a structure or union field. Fields, just like variables, can have attributes associated with the field itself or associated with the type of the field (stored along with the type of the field).</p><div class="odoc-spec"><div class="spec type" id="type-fieldinfo" class="anchored"><a href="#type-fieldinfo" class="anchor"></a><code><span><span class="keyword">and</span> fieldinfo</span><span> = </span><span>{</span></code><table><tr id="type-fieldinfo.fcomp" class="anchored"><td class="def record field"><a href="#type-fieldinfo.fcomp" class="anchor"></a><code><span><span class="keyword">mutable</span> fcomp : <a href="#type-compinfo">compinfo</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The host structure that contains this field. There can be only one <code>compinfo</code> that contains the field.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fieldinfo.fname" class="anchored"><td class="def record field"><a href="#type-fieldinfo.fname" class="anchor"></a><code><span><span class="keyword">mutable</span> fname : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The name of the field. Might be the value of <a href="#val-missingFieldName"><code>missingFieldName</code></a> in which case it must be a bitfield and is not printed and it does not participate in initialization</p><span class="comment-delim">*)</span></td></tr><tr id="type-fieldinfo.ftype" class="anchored"><td class="def record field"><a href="#type-fieldinfo.ftype" class="anchor"></a><code><span><span class="keyword">mutable</span> ftype : <a href="#type-typ">typ</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The type</p><span class="comment-delim">*)</span></td></tr><tr id="type-fieldinfo.fbitfield" class="anchored"><td class="def record field"><a href="#type-fieldinfo.fbitfield" class="anchor"></a><code><span><span class="keyword">mutable</span> fbitfield : <span>int option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>If a bitfield then ftype should be an integer type and the width of the bitfield must be 0 or a positive integer smaller or equal to the width of the integer type. A field of width 0 is used in C to control the alignment of fields.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fieldinfo.fattr" class="anchored"><td class="def record field"><a href="#type-fieldinfo.fattr" class="anchor"></a><code><span><span class="keyword">mutable</span> fattr : <a href="#type-attributes">attributes</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The attributes for this field (not for its type)</p><span class="comment-delim">*)</span></td></tr><tr id="type-fieldinfo.floc" class="anchored"><td class="def record field"><a href="#type-fieldinfo.floc" class="anchor"></a><code><span><span class="keyword">mutable</span> floc : <a href="#type-location">location</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The location where this field is defined</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Information about a struct/union field</p></div></div><p><b>Enumerations.</b> Information about an enumeration. This is shared by all references to an enumeration. Make sure you have a <code>GEnumTag</code> for each of of these.</p><div class="odoc-spec"><div class="spec type" id="type-enuminfo" class="anchored"><a href="#type-enuminfo" class="anchor"></a><code><span><span class="keyword">and</span> enuminfo</span><span> = </span><span>{</span></code><table><tr id="type-enuminfo.ename" class="anchored"><td class="def record field"><a href="#type-enuminfo.ename" class="anchor"></a><code><span><span class="keyword">mutable</span> ename : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The name. Always non-empty.</p><span class="comment-delim">*)</span></td></tr><tr id="type-enuminfo.eitems" class="anchored"><td class="def record field"><a href="#type-enuminfo.eitems" class="anchor"></a><code><span><span class="keyword">mutable</span> eitems : <span><span>(string * <a href="#type-exp">exp</a> * <a href="#type-location">location</a>)</span> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Items with names and values. This list should be non-empty. The item values must be compile-time constants.</p><span class="comment-delim">*)</span></td></tr><tr id="type-enuminfo.eattr" class="anchored"><td class="def record field"><a href="#type-enuminfo.eattr" class="anchor"></a><code><span><span class="keyword">mutable</span> eattr : <a href="#type-attributes">attributes</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The attributes that are defined at the same time as the enumeration type. These attributes can be supplemented individually at each reference to this <code>enuminfo</code> using the <code>TEnum</code> type constructor.</p><span class="comment-delim">*)</span></td></tr><tr id="type-enuminfo.ereferenced" class="anchored"><td class="def record field"><a href="#type-enuminfo.ereferenced" class="anchor"></a><code><span><span class="keyword">mutable</span> ereferenced : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>True if used. Initially set to false</p><span class="comment-delim">*)</span></td></tr><tr id="type-enuminfo.ekind" class="anchored"><td class="def record field"><a href="#type-enuminfo.ekind" class="anchor"></a><code><span><span class="keyword">mutable</span> ekind : <a href="#type-ikind">ikind</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The integer kind used to represent this enum. Per ANSI-C, this should always be IInt, but gcc allows other integer kinds</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Information about an enumeration</p></div></div><div class="odoc-spec"><div class="spec type" id="type-typeinfo" class="anchored"><a href="#type-typeinfo" class="anchor"></a><code><span><span class="keyword">and</span> typeinfo</span><span> = </span><span>{</span></code><table><tr id="type-typeinfo.tname" class="anchored"><td class="def record field"><a href="#type-typeinfo.tname" class="anchor"></a><code><span><span class="keyword">mutable</span> tname : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The name. Can be empty only in a <code>GType</code> when introducing a composite or enumeration tag. If empty cannot be referred to from the file</p><span class="comment-delim">*)</span></td></tr><tr id="type-typeinfo.ttype" class="anchored"><td class="def record field"><a href="#type-typeinfo.ttype" class="anchor"></a><code><span><span class="keyword">mutable</span> ttype : <a href="#type-typ">typ</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The actual type. This includes the attributes that were present in the typedef</p><span class="comment-delim">*)</span></td></tr><tr id="type-typeinfo.treferenced" class="anchored"><td class="def record field"><a href="#type-typeinfo.treferenced" class="anchor"></a><code><span><span class="keyword">mutable</span> treferenced : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>True if used. Initially set to false</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Information about a defined type</p></div></div><p><b>Variables.</b> Each local or global variable is represented by a unique <a href="#type-varinfo"><code>varinfo</code></a> structure. A global <a href="#type-varinfo"><code>varinfo</code></a> can be introduced with the <code>GVarDecl</code> or <code>GVar</code> or <code>GFun</code> globals. A local varinfo can be introduced as part of a function definition <a href="#type-fundec"><code>fundec</code></a>.</p><p>All references to a given global or local variable must refer to the same copy of the <code>varinfo</code>. Each <code>varinfo</code> has a globally unique identifier that can be used to index maps and hashtables (the name can also be used for this purpose, except for locals from different functions). This identifier is constructor using a global counter.</p><p>It is very important that you construct <code>varinfo</code> structures using only one of the following functions:</p><ul><li><a href="#val-makeGlobalVar"><code>makeGlobalVar</code></a> : to make a global variable</li><li><a href="#val-makeTempVar"><code>makeTempVar</code></a> : to make a temporary local variable whose name will be generated so that to avoid conflict with other locals.</li><li><a href="#val-makeLocalVar"><code>makeLocalVar</code></a> : like <a href="#val-makeTempVar"><code>makeTempVar</code></a> but you can specify the exact name to be used.</li><li><a href="#val-copyVarinfo"><code>copyVarinfo</code></a>: make a shallow copy of a varinfo assigning a new name and a new unique identifier</li></ul><p>A <code>varinfo</code> is also used in a function type to denote the list of formals.</p><div class="odoc-spec"><div class="spec type" id="type-varinfo" class="anchored"><a href="#type-varinfo" class="anchor"></a><code><span><span class="keyword">and</span> varinfo</span><span> = </span><span>{</span></code><table><tr id="type-varinfo.vname" class="anchored"><td class="def record field"><a href="#type-varinfo.vname" class="anchor"></a><code><span><span class="keyword">mutable</span> vname : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The name of the variable. Cannot be empty. It is primarily your responsibility to ensure the uniqueness of a variable name. For local variables <a href="#val-makeTempVar"><code>makeTempVar</code></a> helps you ensure that the name is unique.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vtype" class="anchored"><td class="def record field"><a href="#type-varinfo.vtype" class="anchor"></a><code><span><span class="keyword">mutable</span> vtype : <a href="#type-typ">typ</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The declared type of the variable.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vattr" class="anchored"><td class="def record field"><a href="#type-varinfo.vattr" class="anchor"></a><code><span><span class="keyword">mutable</span> vattr : <a href="#type-attributes">attributes</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A list of attributes associated with the variable.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vstorage" class="anchored"><td class="def record field"><a href="#type-varinfo.vstorage" class="anchor"></a><code><span><span class="keyword">mutable</span> vstorage : <a href="#type-storage">storage</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The storage-class</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vglob" class="anchored"><td class="def record field"><a href="#type-varinfo.vglob" class="anchor"></a><code><span><span class="keyword">mutable</span> vglob : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>True if this is a global variable</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vinline" class="anchored"><td class="def record field"><a href="#type-varinfo.vinline" class="anchor"></a><code><span><span class="keyword">mutable</span> vinline : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Whether this varinfo is for an inline function.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vdecl" class="anchored"><td class="def record field"><a href="#type-varinfo.vdecl" class="anchor"></a><code><span><span class="keyword">mutable</span> vdecl : <a href="#type-location">location</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Location of variable declaration.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vinit" class="anchored"><td class="def record field"><a href="#type-varinfo.vinit" class="anchor"></a><code><span>vinit : <a href="#type-initinfo">initinfo</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Optional initializer. Only used for static and global variables. Initializers for other types of local variables are turned into assignments. Not mutable because the init field in initinfo is mutable already.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vid" class="anchored"><td class="def record field"><a href="#type-varinfo.vid" class="anchor"></a><code><span><span class="keyword">mutable</span> vid : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A unique integer identifier. This field will be set for you if you use one of the <a href="#val-makeFormalVar"><code>makeFormalVar</code></a>, <a href="#val-makeLocalVar"><code>makeLocalVar</code></a>, <a href="#val-makeTempVar"><code>makeTempVar</code></a>, <a href="#val-makeGlobalVar"><code>makeGlobalVar</code></a>, or <a href="#val-copyVarinfo"><code>copyVarinfo</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vaddrof" class="anchored"><td class="def record field"><a href="#type-varinfo.vaddrof" class="anchor"></a><code><span><span class="keyword">mutable</span> vaddrof : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>True if the address of this variable is taken. CIL will set these flags when it parses C, but you should make sure to set the flag whenever your transformation create <code>AddrOf</code> expression.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vreferenced" class="anchored"><td class="def record field"><a href="#type-varinfo.vreferenced" class="anchor"></a><code><span><span class="keyword">mutable</span> vreferenced : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>True if this variable is ever referenced. This is computed by <a href="Rmtmps/index.html#val-removeUnusedTemps"><code>Rmtmps.removeUnusedTemps</code></a>. It is safe to just initialize this to False</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vdescr" class="anchored"><td class="def record field"><a href="#type-varinfo.vdescr" class="anchor"></a><code><span><span class="keyword">mutable</span> vdescr : <a href="Pretty/index.html#type-doc">Pretty.doc</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For most temporary variables, a description of what the var holds. (e.g. for temporaries used for function call results, this string is a representation of the function call.)</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vdescrpure" class="anchored"><td class="def record field"><a href="#type-varinfo.vdescrpure" class="anchor"></a><code><span><span class="keyword">mutable</span> vdescrpure : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Indicates whether the vdescr above is a pure expression or call. Printing a non-pure vdescr more than once may yield incorrect results.</p><span class="comment-delim">*)</span></td></tr><tr id="type-varinfo.vhasdeclinstruction" class="anchored"><td class="def record field"><a href="#type-varinfo.vhasdeclinstruction" class="anchor"></a><code><span><span class="keyword">mutable</span> vhasdeclinstruction : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Indicates whether a VarDecl instruction was generated for this variable. Only applies to local variables. Currently, this is relevant for when to print the declaration. If this is true, it might be incorrect to print the declaration at the beginning of the function, rather than where the VarDecl instruction is. This was introduced to handle VLAs.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Information about a variable.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-storage" class="anchored"><a href="#type-storage" class="anchor"></a><code><span><span class="keyword">and</span> storage</span><span> = </span></code><table><tr id="type-storage.NoStorage" class="anchored"><td class="def variant constructor"><a href="#type-storage.NoStorage" class="anchor"></a><code><span>| </span><span><span class="constructor">NoStorage</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The default storage. Nothing is printed</p><span class="comment-delim">*)</span></td></tr><tr id="type-storage.Static" class="anchored"><td class="def variant constructor"><a href="#type-storage.Static" class="anchor"></a><code><span>| </span><span><span class="constructor">Static</span></span></code></td></tr><tr id="type-storage.Register" class="anchored"><td class="def variant constructor"><a href="#type-storage.Register" class="anchor"></a><code><span>| </span><span><span class="constructor">Register</span></span></code></td></tr><tr id="type-storage.Extern" class="anchored"><td class="def variant constructor"><a href="#type-storage.Extern" class="anchor"></a><code><span>| </span><span><span class="constructor">Extern</span></span></code></td></tr></table></div><div class="spec-doc"><p>Storage-class information</p></div></div><p><b>Expressions.</b> The CIL expression language contains only the side-effect free expressions of C. They are represented as the type <a href="#type-exp"><code>exp</code></a>. There are several interesting aspects of CIL expressions:</p><p>Integer and floating point constants can carry their textual representation. This way the integer 15 can be printed as 0xF if that is how it occurred in the source.</p><p>CIL uses 64 bits to represent the integer constants and also stores the width of the integer type. Care must be taken to ensure that the constant is representable with the given width. Use the functions <a href="#val-kinteger"><code>kinteger</code></a>, <a href="#val-kinteger64"><code>kinteger64</code></a> and <a href="#val-integer"><code>integer</code></a> to construct constant expressions. CIL predefines the constants <a href="#val-zero"><code>zero</code></a>, <a href="#val-one"><code>one</code></a> and <a href="#val-mone"><code>mone</code></a> (for -1).</p><p>Use the function <a href="#val-isConstant"><code>isConstant</code></a> to test if an expression is a constant.</p><p>CIL keeps the type of all unary and binary expressions. You can think of that type qualifying the operator. Furthermore there are different operators for arithmetic and comparisons on arithmetic types and on pointers.</p><p>Another unusual aspect of CIL is that the implicit conversion between an expression of array type and one of pointer type is made explicit, using the <code>StartOf</code> expression constructor (which is not printed). If you apply the <code>AddrOf}</code>constructor to an lvalue of type <code>T</code> then you will be getting an expression of type <code>TPtr(T)</code>.</p><p>You can find the type of an expression with <a href="#val-typeOf"><code>typeOf</code></a>.</p><p>You can perform constant folding on expressions using the function <a href="#val-constFold"><code>constFold</code></a>.</p><div class="odoc-spec"><div class="spec type" id="type-exp" class="anchored"><a href="#type-exp" class="anchor"></a><code><span><span class="keyword">and</span> exp</span><span> = </span></code><table><tr id="type-exp.Const" class="anchored"><td class="def variant constructor"><a href="#type-exp.Const" class="anchor"></a><code><span>| </span><span><span class="constructor">Const</span> <span class="keyword">of</span> <a href="#type-constant">constant</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Constant</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.Lval" class="anchored"><td class="def variant constructor"><a href="#type-exp.Lval" class="anchor"></a><code><span>| </span><span><span class="constructor">Lval</span> <span class="keyword">of</span> <a href="#type-lval">lval</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Lvalue</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.SizeOf" class="anchored"><td class="def variant constructor"><a href="#type-exp.SizeOf" class="anchor"></a><code><span>| </span><span><span class="constructor">SizeOf</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>sizeof(&lt;type&gt;). Has <code>unsigned int</code> type (ISO 6.5.3.4). This is not turned into a constant because some transformations might want to change types</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.Real" class="anchored"><td class="def variant constructor"><a href="#type-exp.Real" class="anchor"></a><code><span>| </span><span><span class="constructor">Real</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>__real__(&lt;expression&gt;)</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.Imag" class="anchored"><td class="def variant constructor"><a href="#type-exp.Imag" class="anchor"></a><code><span>| </span><span><span class="constructor">Imag</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>__imag__(&lt;expression&gt;)</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.SizeOfE" class="anchored"><td class="def variant constructor"><a href="#type-exp.SizeOfE" class="anchor"></a><code><span>| </span><span><span class="constructor">SizeOfE</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>sizeof(&lt;expression&gt;)</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.SizeOfStr" class="anchored"><td class="def variant constructor"><a href="#type-exp.SizeOfStr" class="anchor"></a><code><span>| </span><span><span class="constructor">SizeOfStr</span> <span class="keyword">of</span> string</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>sizeof(string_literal). We separate this case out because this is the only instance in which a string literal should not be treated as having type pointer to character.</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.AlignOf" class="anchored"><td class="def variant constructor"><a href="#type-exp.AlignOf" class="anchor"></a><code><span>| </span><span><span class="constructor">AlignOf</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This corresponds to the GCC __alignof_. Has <code>unsigned int</code> type</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.AlignOfE" class="anchored"><td class="def variant constructor"><a href="#type-exp.AlignOfE" class="anchor"></a><code><span>| </span><span><span class="constructor">AlignOfE</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></td></tr><tr id="type-exp.UnOp" class="anchored"><td class="def variant constructor"><a href="#type-exp.UnOp" class="anchor"></a><code><span>| </span><span><span class="constructor">UnOp</span> <span class="keyword">of</span> <a href="#type-unop">unop</a> * <a href="#type-exp">exp</a> * <a href="#type-typ">typ</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unary operation. Includes the type of the result.</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.BinOp" class="anchored"><td class="def variant constructor"><a href="#type-exp.BinOp" class="anchor"></a><code><span>| </span><span><span class="constructor">BinOp</span> <span class="keyword">of</span> <a href="#type-binop">binop</a> * <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a> * <a href="#type-typ">typ</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Binary operation. Includes the type of the result. The arithmetic conversions are made explicit for the arguments.</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.Question" class="anchored"><td class="def variant constructor"><a href="#type-exp.Question" class="anchor"></a><code><span>| </span><span><span class="constructor">Question</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a> * <a href="#type-typ">typ</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>(a ? b : c) operation. Includes the type of the result</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.CastE" class="anchored"><td class="def variant constructor"><a href="#type-exp.CastE" class="anchor"></a><code><span>| </span><span><span class="constructor">CastE</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <a href="#type-exp">exp</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Use <a href="#val-mkCast"><code>mkCast</code></a> to make casts.</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.AddrOf" class="anchored"><td class="def variant constructor"><a href="#type-exp.AddrOf" class="anchor"></a><code><span>| </span><span><span class="constructor">AddrOf</span> <span class="keyword">of</span> <a href="#type-lval">lval</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Always use <a href="#val-mkAddrOf"><code>mkAddrOf</code></a> to construct one of these. Apply to an lvalue of type <code>T</code> yields an expression of type <code>TPtr(T)</code>. Use <a href="#val-mkAddrOrStartOf"><code>mkAddrOrStartOf</code></a> to make one of these if you are not sure which one to use.</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.AddrOfLabel" class="anchored"><td class="def variant constructor"><a href="#type-exp.AddrOfLabel" class="anchor"></a><code><span>| </span><span><span class="constructor">AddrOfLabel</span> <span class="keyword">of</span> <span><a href="#type-stmt">stmt</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The address of a label, using GCC's label-as-value extension. If you want to use these, you must set <a href="#val-useComputedGoto"><code>useComputedGoto</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-exp.StartOf" class="anchored"><td class="def variant constructor"><a href="#type-exp.StartOf" class="anchor"></a><code><span>| </span><span><span class="constructor">StartOf</span> <span class="keyword">of</span> <a href="#type-lval">lval</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Conversion from an array to a pointer to the beginning of the array. Given an lval of type <code>TArray(T)</code> produces an expression of type <code>TPtr(T)</code>. Use <a href="#val-mkAddrOrStartOf"><code>mkAddrOrStartOf</code></a> to make one of these if you are not sure which one to use. In C this operation is implicit, the <code>StartOf</code> operator is not printed. We have it in CIL because it makes the typing rules simpler.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Expressions (Side-effect free)</p></div></div><p><b>Constants.</b></p><div class="odoc-spec"><div class="spec type" id="type-wstring_type" class="anchored"><a href="#type-wstring_type" class="anchor"></a><code><span><span class="keyword">and</span> wstring_type</span><span> = </span></code><table><tr id="type-wstring_type.Wchar_t" class="anchored"><td class="def variant constructor"><a href="#type-wstring_type.Wchar_t" class="anchor"></a><code><span>| </span><span><span class="constructor">Wchar_t</span></span></code></td></tr><tr id="type-wstring_type.Char16_t" class="anchored"><td class="def variant constructor"><a href="#type-wstring_type.Char16_t" class="anchor"></a><code><span>| </span><span><span class="constructor">Char16_t</span></span></code></td></tr><tr id="type-wstring_type.Char32_t" class="anchored"><td class="def variant constructor"><a href="#type-wstring_type.Char32_t" class="anchor"></a><code><span>| </span><span><span class="constructor">Char32_t</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-encoding" class="anchored"><a href="#type-encoding" class="anchor"></a><code><span><span class="keyword">and</span> encoding</span><span> = </span></code><table><tr id="type-encoding.No_encoding" class="anchored"><td class="def variant constructor"><a href="#type-encoding.No_encoding" class="anchor"></a><code><span>| </span><span><span class="constructor">No_encoding</span></span></code></td></tr><tr id="type-encoding.Utf8" class="anchored"><td class="def variant constructor"><a href="#type-encoding.Utf8" class="anchor"></a><code><span>| </span><span><span class="constructor">Utf8</span></span></code></td></tr></table></div></div><div class="odoc-spec"><div class="spec type" id="type-constant" class="anchored"><a href="#type-constant" class="anchor"></a><code><span><span class="keyword">and</span> constant</span><span> = </span></code><table><tr id="type-constant.CInt" class="anchored"><td class="def variant constructor"><a href="#type-constant.CInt" class="anchor"></a><code><span>| </span><span><span class="constructor">CInt</span> <span class="keyword">of</span> <a href="Cilint/index.html#type-cilint">Cilint.cilint</a> * <a href="#type-ikind">ikind</a> * <span>string option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Integer constant. Give the ikind (see ISO9899 6.1.3.2) and the textual representation, if available. (This allows us to print a constant as, for example, 0xF instead of 15.) Use <a href="#val-integer"><code>integer</code></a> or <a href="#val-kinteger"><code>kinteger</code></a> to create these.</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant.CStr" class="anchored"><td class="def variant constructor"><a href="#type-constant.CStr" class="anchor"></a><code><span>| </span><span><span class="constructor">CStr</span> <span class="keyword">of</span> string * <a href="#type-encoding">encoding</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>String constant. The escape characters inside the string have been already interpreted. This constant has pointer to character type! The only case when you would like a string literal to have an array type is when it is an argument to sizeof. In that case you should use SizeOfStr.</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant.CWStr" class="anchored"><td class="def variant constructor"><a href="#type-constant.CWStr" class="anchor"></a><code><span>| </span><span><span class="constructor">CWStr</span> <span class="keyword">of</span> <span>int64 list</span> * <a href="#type-wstring_type">wstring_type</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Wide character string constant. Note that the local interpretation of such a literal depends on <a href="#val-wcharType"><code>wcharType</code></a> and <a href="#val-wcharKind"><code>wcharKind</code></a>. Such a constant has type pointer to <a href="#val-wcharType"><code>wcharType</code></a>. The escape characters in the string have not been &quot;interpreted&quot; in the sense that L&quot;A\xabcd&quot; remains &quot;A\xabcd&quot; rather than being represented as the wide character list with two elements: 65 and 43981. That &quot;interpretation&quot; depends on the underlying wide character type.</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant.CChr" class="anchored"><td class="def variant constructor"><a href="#type-constant.CChr" class="anchor"></a><code><span>| </span><span><span class="constructor">CChr</span> <span class="keyword">of</span> char</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Character constant. This has type int, so use charConstToInt to read the value in case sign-extension is needed.</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant.CReal" class="anchored"><td class="def variant constructor"><a href="#type-constant.CReal" class="anchor"></a><code><span>| </span><span><span class="constructor">CReal</span> <span class="keyword">of</span> float * <a href="#type-fkind">fkind</a> * <span>string option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Floating point constant. Give the fkind (see ISO 6.4.4.2) and also the textual representation, if available.</p><span class="comment-delim">*)</span></td></tr><tr id="type-constant.CEnum" class="anchored"><td class="def variant constructor"><a href="#type-constant.CEnum" class="anchor"></a><code><span>| </span><span><span class="constructor">CEnum</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * string * <a href="#type-enuminfo">enuminfo</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An enumeration constant with the given value, name, from the given enuminfo. This is used only if <a href="#val-lowerConstants"><code>lowerConstants</code></a> is true (default). Use <a href="#val-constFoldVisitor"><code>constFoldVisitor</code></a> to replace these with integer constants.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Literal constants</p></div></div><div class="odoc-spec"><div class="spec type" id="type-unop" class="anchored"><a href="#type-unop" class="anchor"></a><code><span><span class="keyword">and</span> unop</span><span> = </span></code><table><tr id="type-unop.Neg" class="anchored"><td class="def variant constructor"><a href="#type-unop.Neg" class="anchor"></a><code><span>| </span><span><span class="constructor">Neg</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Unary minus</p><span class="comment-delim">*)</span></td></tr><tr id="type-unop.BNot" class="anchored"><td class="def variant constructor"><a href="#type-unop.BNot" class="anchor"></a><code><span>| </span><span><span class="constructor">BNot</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Bitwise complement (~)</p><span class="comment-delim">*)</span></td></tr><tr id="type-unop.LNot" class="anchored"><td class="def variant constructor"><a href="#type-unop.LNot" class="anchor"></a><code><span>| </span><span><span class="constructor">LNot</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Logical Not (!)</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Unary operators</p></div></div><div class="odoc-spec"><div class="spec type" id="type-binop" class="anchored"><a href="#type-binop" class="anchor"></a><code><span><span class="keyword">and</span> binop</span><span> = </span></code><table><tr id="type-binop.PlusA" class="anchored"><td class="def variant constructor"><a href="#type-binop.PlusA" class="anchor"></a><code><span>| </span><span><span class="constructor">PlusA</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>arithmetic +</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.PlusPI" class="anchored"><td class="def variant constructor"><a href="#type-binop.PlusPI" class="anchor"></a><code><span>| </span><span><span class="constructor">PlusPI</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>pointer + integer</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.IndexPI" class="anchored"><td class="def variant constructor"><a href="#type-binop.IndexPI" class="anchor"></a><code><span>| </span><span><span class="constructor">IndexPI</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>pointer + integer but only when it arises from an expression <code>e[i]</code> when <code>e</code> is a pointer and not an array. This is semantically the same as PlusPI but CCured uses this as a hint that the integer is probably positive.</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.MinusA" class="anchored"><td class="def variant constructor"><a href="#type-binop.MinusA" class="anchor"></a><code><span>| </span><span><span class="constructor">MinusA</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>arithmetic -</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.MinusPI" class="anchored"><td class="def variant constructor"><a href="#type-binop.MinusPI" class="anchor"></a><code><span>| </span><span><span class="constructor">MinusPI</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>pointer - integer</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.MinusPP" class="anchored"><td class="def variant constructor"><a href="#type-binop.MinusPP" class="anchor"></a><code><span>| </span><span><span class="constructor">MinusPP</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>pointer - pointer</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Mult" class="anchored"><td class="def variant constructor"><a href="#type-binop.Mult" class="anchor"></a><code><span>| </span><span><span class="constructor">Mult</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>*</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Div" class="anchored"><td class="def variant constructor"><a href="#type-binop.Div" class="anchor"></a><code><span>| </span><span><span class="constructor">Div</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>/</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Mod" class="anchored"><td class="def variant constructor"><a href="#type-binop.Mod" class="anchor"></a><code><span>| </span><span><span class="constructor">Mod</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>%</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Shiftlt" class="anchored"><td class="def variant constructor"><a href="#type-binop.Shiftlt" class="anchor"></a><code><span>| </span><span><span class="constructor">Shiftlt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>shift left</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Shiftrt" class="anchored"><td class="def variant constructor"><a href="#type-binop.Shiftrt" class="anchor"></a><code><span>| </span><span><span class="constructor">Shiftrt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>shift right</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Lt" class="anchored"><td class="def variant constructor"><a href="#type-binop.Lt" class="anchor"></a><code><span>| </span><span><span class="constructor">Lt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&lt; (arithmetic comparison)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Gt" class="anchored"><td class="def variant constructor"><a href="#type-binop.Gt" class="anchor"></a><code><span>| </span><span><span class="constructor">Gt</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&gt; (arithmetic comparison)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Le" class="anchored"><td class="def variant constructor"><a href="#type-binop.Le" class="anchor"></a><code><span>| </span><span><span class="constructor">Le</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&lt;= (arithmetic comparison)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Ge" class="anchored"><td class="def variant constructor"><a href="#type-binop.Ge" class="anchor"></a><code><span>| </span><span><span class="constructor">Ge</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&gt; (arithmetic comparison)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Eq" class="anchored"><td class="def variant constructor"><a href="#type-binop.Eq" class="anchor"></a><code><span>| </span><span><span class="constructor">Eq</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>== (arithmetic comparison)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.Ne" class="anchored"><td class="def variant constructor"><a href="#type-binop.Ne" class="anchor"></a><code><span>| </span><span><span class="constructor">Ne</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>!= (arithmetic comparison)</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.BAnd" class="anchored"><td class="def variant constructor"><a href="#type-binop.BAnd" class="anchor"></a><code><span>| </span><span><span class="constructor">BAnd</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>bitwise and</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.BXor" class="anchored"><td class="def variant constructor"><a href="#type-binop.BXor" class="anchor"></a><code><span>| </span><span><span class="constructor">BXor</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>exclusive-or</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.BOr" class="anchored"><td class="def variant constructor"><a href="#type-binop.BOr" class="anchor"></a><code><span>| </span><span><span class="constructor">BOr</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>inclusive-or</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.LAnd" class="anchored"><td class="def variant constructor"><a href="#type-binop.LAnd" class="anchor"></a><code><span>| </span><span><span class="constructor">LAnd</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>logical and. Unlike other expressions this one does not always evaluate both operands. If you want to use these, you must set <a href="#val-useLogicalOperators"><code>useLogicalOperators</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-binop.LOr" class="anchored"><td class="def variant constructor"><a href="#type-binop.LOr" class="anchor"></a><code><span>| </span><span><span class="constructor">LOr</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>logical or. Unlike other expressions this one does not always evaluate both operands. If you want to use these, you must set <a href="#val-useLogicalOperators"><code>useLogicalOperators</code></a>.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Binary operations</p></div></div><div class="odoc-spec"><div class="spec type" id="type-lval" class="anchored"><a href="#type-lval" class="anchor"></a><code><span><span class="keyword">and</span> lval</span><span> = <a href="#type-lhost">lhost</a> * <a href="#type-offset">offset</a></span></code></div><div class="spec-doc"><p><b>Lvalues.</b> Lvalues are the sublanguage of expressions that can appear at the left of an assignment or as operand to the address-of operator. In C the syntax for lvalues is not always a good indication of the meaning of the lvalue. For example the C value</p><pre>a[0][1][2]</pre><p>might involve 1, 2 or 3 memory reads when used in an expression context, depending on the declared type of the variable <code>a</code>. If <code>a</code> has type <code>int
[4][4][4]</code> then we have one memory read from somewhere inside the area that stores the array <code>a</code>. On the other hand if <code>a</code> has type <code>int ***</code> then the expression really means <code>* ( * ( * (a + 0) + 1) + 2)</code>, in which case it is clear that it involves three separate memory operations.</p><p>An lvalue denotes the contents of a range of memory addresses. This range is denoted as a host object along with an offset within the object. The host object can be of two kinds: a local or global variable, or an object whose address is in a pointer expression. We distinguish the two cases so that we can tell quickly whether we are accessing some component of a variable directly or we are accessing a memory location through a pointer. To make it easy to tell what an lvalue means CIL represents lvalues as a host object and an offset (see <a href="#type-lval"><code>lval</code></a>). The host object (represented as <a href="#type-lhost"><code>lhost</code></a>) can be a local or global variable or can be the object pointed-to by a pointer expression. The offset (represented as <a href="#type-offset"><code>offset</code></a>) is a sequence of field or array index designators.</p><p>Both the typing rules and the meaning of an lvalue is very precisely specified in CIL.</p><p>The following are a few useful function for operating on lvalues:</p><ul><li><a href="#val-mkMem"><code>mkMem</code></a> - makes an lvalue of <code>Mem</code> kind. Use this to ensure that certain equivalent forms of lvalues are canonized. For example, <code>*&amp;x = x</code>.</li><li><a href="#val-typeOfLval"><code>typeOfLval</code></a> - the type of an lvalue</li><li><a href="#val-typeOffset"><code>typeOffset</code></a> - the type of an offset, given the type of the host.</li><li><a href="#val-addOffset"><code>addOffset</code></a> and <a href="#val-addOffsetLval"><code>addOffsetLval</code></a> - extend sequences of offsets.</li><li><a href="#val-removeOffset"><code>removeOffset</code></a> and <a href="#val-removeOffsetLval"><code>removeOffsetLval</code></a> - shrink sequences of offsets.</li></ul><p>The following equivalences hold</p><pre>Mem(AddrOf(Mem a, aoff)), off   = Mem a, aoff + off
Mem(AddrOf(Var v, aoff)), off   = Var v, aoff + off
AddrOf (Mem a, NoOffset)        = a</pre></div></div><div class="odoc-spec"><div class="spec type" id="type-lhost" class="anchored"><a href="#type-lhost" class="anchor"></a><code><span><span class="keyword">and</span> lhost</span><span> = </span></code><table><tr id="type-lhost.Var" class="anchored"><td class="def variant constructor"><a href="#type-lhost.Var" class="anchor"></a><code><span>| </span><span><span class="constructor">Var</span> <span class="keyword">of</span> <a href="#type-varinfo">varinfo</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The host is a variable.</p><span class="comment-delim">*)</span></td></tr><tr id="type-lhost.Mem" class="anchored"><td class="def variant constructor"><a href="#type-lhost.Mem" class="anchor"></a><code><span>| </span><span><span class="constructor">Mem</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The host is an object of type <code>T</code> when the expression has pointer <code>TPtr(T)</code>.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>The host part of an <a href="#type-lval"><code>lval</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-offset" class="anchored"><a href="#type-offset" class="anchor"></a><code><span><span class="keyword">and</span> offset</span><span> = </span></code><table><tr id="type-offset.NoOffset" class="anchored"><td class="def variant constructor"><a href="#type-offset.NoOffset" class="anchor"></a><code><span>| </span><span><span class="constructor">NoOffset</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>No offset. Can be applied to any lvalue and does not change either the starting address or the type. This is used when the lval consists of just a host or as a terminator in a list of other kinds of offsets.</p><span class="comment-delim">*)</span></td></tr><tr id="type-offset.Field" class="anchored"><td class="def variant constructor"><a href="#type-offset.Field" class="anchor"></a><code><span>| </span><span><span class="constructor">Field</span> <span class="keyword">of</span> <a href="#type-fieldinfo">fieldinfo</a> * <a href="#type-offset">offset</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A field offset. Can be applied only to an lvalue that denotes a structure or a union that contains the mentioned field. This advances the offset to the beginning of the mentioned field and changes the type to the type of the mentioned field.</p><span class="comment-delim">*)</span></td></tr><tr id="type-offset.Index" class="anchored"><td class="def variant constructor"><a href="#type-offset.Index" class="anchor"></a><code><span>| </span><span><span class="constructor">Index</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-offset">offset</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An array index offset. Can be applied only to an lvalue that denotes an array. This advances the starting address of the lval to the beginning of the mentioned array element and changes the denoted type to be the type of the array element</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>The offset part of an <a href="#type-lval"><code>lval</code></a>. Each offset can be applied to certain kinds of lvalues and its effect is that it advances the starting address of the lvalue and changes the denoted type, essentially focusing to some smaller lvalue that is contained in the original one.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-init" class="anchored"><a href="#type-init" class="anchor"></a><code><span><span class="keyword">and</span> init</span><span> = </span></code><table><tr id="type-init.SingleInit" class="anchored"><td class="def variant constructor"><a href="#type-init.SingleInit" class="anchor"></a><code><span>| </span><span><span class="constructor">SingleInit</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A single initializer</p><span class="comment-delim">*)</span></td></tr><tr id="type-init.CompoundInit" class="anchored"><td class="def variant constructor"><a href="#type-init.CompoundInit" class="anchor"></a><code><span>| </span><span><span class="constructor">CompoundInit</span> <span class="keyword">of</span> <a href="#type-typ">typ</a> * <span><span>(<a href="#type-offset">offset</a> * <a href="#type-init">init</a>)</span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Used only for initializers of structures, unions and arrays. The offsets are all of the form <code>Field(f, NoOffset)</code> or <code>Index(i,
       NoOffset)</code> and specify the field or the index being initialized. For structures all fields must have an initializer (except the unnamed bitfields), in the proper order. This is necessary since the offsets are not printed. For unions there must be exactly one initializer. If the initializer is not for the first field then a field designator is printed. For arrays, however, we allow you to give only a prefix of the initializers. You can scan an initializer list with <a href="#val-foldLeftCompound"><code>foldLeftCompound</code></a>.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p><b>Initializers.</b> A special kind of expressions are those that can appear as initializers for global variables (initialization of local variables is turned into assignments). The initializers are represented as type <a href="#type-init"><code>init</code></a>. You can create initializers with <a href="#val-makeZeroInit"><code>makeZeroInit</code></a> and you can conveniently scan compound initializers them with <a href="#val-foldLeftCompound"><code>foldLeftCompound</code></a>.</p><p>Initializers for global variables.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-initinfo" class="anchored"><a href="#type-initinfo" class="anchor"></a><code><span><span class="keyword">and</span> initinfo</span><span> = </span><span>{</span></code><table><tr id="type-initinfo.init" class="anchored"><td class="def record field"><a href="#type-initinfo.init" class="anchor"></a><code><span><span class="keyword">mutable</span> init : <span><a href="#type-init">init</a> option</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>We want to be able to update an initializer in a variable, so we define it as a mutable field</p></div></div><div class="odoc-spec"><div class="spec type" id="type-fundec" class="anchored"><a href="#type-fundec" class="anchor"></a><code><span><span class="keyword">and</span> fundec</span><span> = </span><span>{</span></code><table><tr id="type-fundec.svar" class="anchored"><td class="def record field"><a href="#type-fundec.svar" class="anchor"></a><code><span><span class="keyword">mutable</span> svar : <a href="#type-varinfo">varinfo</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Holds the name and type as a variable, so we can refer to it easily from the program. All references to this function either in a function call or in a prototype must point to the same <code>varinfo</code>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fundec.sformals" class="anchored"><td class="def record field"><a href="#type-fundec.sformals" class="anchor"></a><code><span><span class="keyword">mutable</span> sformals : <span><a href="#type-varinfo">varinfo</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Formals. These must be in the same order and with the same information as the formal information in the type of the function. Use <a href="#val-setFormals"><code>setFormals</code></a> or <a href="#val-setFunctionType"><code>setFunctionType</code></a> or <a href="#val-makeFormalVar"><code>makeFormalVar</code></a> to set these formals and ensure that they are reflected in the function type. Do not make copies of these because the body refers to them.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fundec.slocals" class="anchored"><td class="def record field"><a href="#type-fundec.slocals" class="anchor"></a><code><span><span class="keyword">mutable</span> slocals : <span><a href="#type-varinfo">varinfo</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Locals. Does NOT include the sformals. Do not make copies of these because the body refers to them.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fundec.smaxid" class="anchored"><td class="def record field"><a href="#type-fundec.smaxid" class="anchor"></a><code><span><span class="keyword">mutable</span> smaxid : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Max local id. Starts at 0. Used for creating the names of new temporary variables. Updated by <a href="#val-makeLocalVar"><code>makeLocalVar</code></a> and <a href="#val-makeTempVar"><code>makeTempVar</code></a>. You can also use <a href="#val-setMaxId"><code>setMaxId</code></a> to set it after you have added the formals and locals.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fundec.sbody" class="anchored"><td class="def record field"><a href="#type-fundec.sbody" class="anchor"></a><code><span><span class="keyword">mutable</span> sbody : <a href="#type-block">block</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The function body.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fundec.smaxstmtid" class="anchored"><td class="def record field"><a href="#type-fundec.smaxstmtid" class="anchor"></a><code><span><span class="keyword">mutable</span> smaxstmtid : <span>int option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>max id of a (reachable) statement in this function, if we have computed it. range = 0 ... (smaxstmtid-1). This is computed by <a href="#val-computeCFGInfo"><code>computeCFGInfo</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-fundec.sallstmts" class="anchored"><td class="def record field"><a href="#type-fundec.sallstmts" class="anchor"></a><code><span><span class="keyword">mutable</span> sallstmts : <span><a href="#type-stmt">stmt</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>After you call <a href="#val-computeCFGInfo"><code>computeCFGInfo</code></a> this field is set to contain all statements in the function</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p><b>Function definitions.</b> A function definition is always introduced with a <code>GFun</code> constructor at the top level. All the information about the function is stored into a <a href="#type-fundec"><code>fundec</code></a>. Some of the information (e.g. its name, type, storage, attributes) is stored as a <a href="#type-varinfo"><code>varinfo</code></a> that is a field of the <code>fundec</code>. To refer to the function from the expression language you must use the <code>varinfo</code>.</p><p>The function definition contains, in addition to the body, a list of all the local variables and separately a list of the formals. Both kind of variables can be referred to in the body of the function. The formals must also be shared with the formals that appear in the function type. For that reason, to manipulate formals you should use the provided functions <a href="#val-makeFormalVar"><code>makeFormalVar</code></a> and <a href="#val-setFormals"><code>setFormals</code></a> and <a href="#val-makeFormalVar"><code>makeFormalVar</code></a>.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-block" class="anchored"><a href="#type-block" class="anchor"></a><code><span><span class="keyword">and</span> block</span><span> = </span><span>{</span></code><table><tr id="type-block.battrs" class="anchored"><td class="def record field"><a href="#type-block.battrs" class="anchor"></a><code><span><span class="keyword">mutable</span> battrs : <a href="#type-attributes">attributes</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Attributes for the block</p><span class="comment-delim">*)</span></td></tr><tr id="type-block.bstmts" class="anchored"><td class="def record field"><a href="#type-block.bstmts" class="anchor"></a><code><span><span class="keyword">mutable</span> bstmts : <span><a href="#type-stmt">stmt</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The statements comprising the block</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>A block is a sequence of statements with the control falling through from one element to the next</p></div></div><div class="odoc-spec"><div class="spec type" id="type-stmt" class="anchored"><a href="#type-stmt" class="anchor"></a><code><span><span class="keyword">and</span> stmt</span><span> = </span><span>{</span></code><table><tr id="type-stmt.labels" class="anchored"><td class="def record field"><a href="#type-stmt.labels" class="anchor"></a><code><span><span class="keyword">mutable</span> labels : <span><a href="#type-label">label</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Whether the statement starts with some labels, case statements or default statements.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmt.skind" class="anchored"><td class="def record field"><a href="#type-stmt.skind" class="anchor"></a><code><span><span class="keyword">mutable</span> skind : <a href="#type-stmtkind">stmtkind</a>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The kind of statement</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmt.sid" class="anchored"><td class="def record field"><a href="#type-stmt.sid" class="anchor"></a><code><span><span class="keyword">mutable</span> sid : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A number (&gt;= 0) that is unique in a function. Filled in only after the CFG is computed.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmt.succs" class="anchored"><td class="def record field"><a href="#type-stmt.succs" class="anchor"></a><code><span><span class="keyword">mutable</span> succs : <span><a href="#type-stmt">stmt</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The successor statements. They can always be computed from the skind and the context in which this statement appears. Filled in only after the CFG is computed.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmt.preds" class="anchored"><td class="def record field"><a href="#type-stmt.preds" class="anchor"></a><code><span><span class="keyword">mutable</span> preds : <span><a href="#type-stmt">stmt</a> list</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The inverse of the succs function.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmt.fallthrough" class="anchored"><td class="def record field"><a href="#type-stmt.fallthrough" class="anchor"></a><code><span><span class="keyword">mutable</span> fallthrough : <span><a href="#type-stmt">stmt</a> option</span>;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The fallthrough successor statement computed from the context of this statement in <a href="#val-computeCFGInfo"><code>computeCFGInfo</code></a>. Useful for the syntactic successor of Goto and Loop.</p><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p><b>Statements</b>. CIL statements are the structural elements that make the CFG. They are represented using the type <a href="#type-stmt"><code>stmt</code></a>. Every statement has a (possibly empty) list of labels. The <a href="#type-stmtkind"><code>stmtkind</code></a> field of a statement indicates what kind of statement it is.</p><p>Use <a href="#val-mkStmt"><code>mkStmt</code></a> to make a statement and the fill-in the fields.</p><p>CIL also comes with support for control-flow graphs. The <code>sid</code> field in <code>stmt</code> can be used to give unique numbers to statements, and the <code>succs</code> and <code>preds</code> fields can be used to maintain a list of successors and predecessors for every statement. The CFG information is not computed by default. Instead you must explicitly use the functions <a href="#val-prepareCFG"><code>prepareCFG</code></a> and <a href="#val-computeCFGInfo"><code>computeCFGInfo</code></a> to do it.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-label" class="anchored"><a href="#type-label" class="anchor"></a><code><span><span class="keyword">and</span> label</span><span> = </span></code><table><tr id="type-label.Label" class="anchored"><td class="def variant constructor"><a href="#type-label.Label" class="anchor"></a><code><span>| </span><span><span class="constructor">Label</span> <span class="keyword">of</span> string * <a href="#type-location">location</a> * bool</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A real label. If the bool is &quot;true&quot;, the label is from the input source program. If the bool is &quot;false&quot;, the label was created by CIL or some other transformation</p><span class="comment-delim">*)</span></td></tr><tr id="type-label.Case" class="anchored"><td class="def variant constructor"><a href="#type-label.Case" class="anchor"></a><code><span>| </span><span><span class="constructor">Case</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-location">location</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A case statement. This expression is lowered into a constant if <a href="#val-lowerConstants"><code>lowerConstants</code></a> is set to true. Second location is just for label.</p><span class="comment-delim">*)</span></td></tr><tr id="type-label.CaseRange" class="anchored"><td class="def variant constructor"><a href="#type-label.CaseRange" class="anchor"></a><code><span>| </span><span><span class="constructor">CaseRange</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-exp">exp</a> * <a href="#type-location">location</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A case statement corresponding to a range of values (GCC's extension). Both expressions are lowered into constants if <a href="#val-lowerConstants"><code>lowerConstants</code></a> is set to true. If you want to use these, you must set <a href="#val-useCaseRange"><code>useCaseRange</code></a>. Second location is just for label.</p><span class="comment-delim">*)</span></td></tr><tr id="type-label.Default" class="anchored"><td class="def variant constructor"><a href="#type-label.Default" class="anchor"></a><code><span>| </span><span><span class="constructor">Default</span> <span class="keyword">of</span> <a href="#type-location">location</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A default statement. Second location is just for label.</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Labels</p></div></div><div class="odoc-spec"><div class="spec type" id="type-stmtkind" class="anchored"><a href="#type-stmtkind" class="anchor"></a><code><span><span class="keyword">and</span> stmtkind</span><span> = </span></code><table><tr id="type-stmtkind.Instr" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Instr" class="anchor"></a><code><span>| </span><span><span class="constructor">Instr</span> <span class="keyword">of</span> <span><a href="#type-instr">instr</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A group of instructions that do not contain control flow. Control implicitly falls through.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.Return" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Return" class="anchor"></a><code><span>| </span><span><span class="constructor">Return</span> <span class="keyword">of</span> <span><a href="#type-exp">exp</a> option</span> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The return statement. This is a leaf in the CFG.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.Goto" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Goto" class="anchor"></a><code><span>| </span><span><span class="constructor">Goto</span> <span class="keyword">of</span> <span><a href="#type-stmt">stmt</a> <span class="xref-unresolved">Stdlib</span>.ref</span> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A goto statement. Appears from actual goto's in the code or from goto's that have been inserted during elaboration. The reference points to the statement that is the target of the Goto. This means that you have to update the reference whenever you replace the target statement. The target statement MUST have at least a label.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.ComputedGoto" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.ComputedGoto" class="anchor"></a><code><span>| </span><span><span class="constructor">ComputedGoto</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A computed goto using GCC's label-as-value extension. If you want to use these, you must set <a href="#val-useComputedGoto"><code>useComputedGoto</code></a>.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.Break" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Break" class="anchor"></a><code><span>| </span><span><span class="constructor">Break</span> <span class="keyword">of</span> <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A break to the end of the nearest enclosing Loop or Switch</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.Continue" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Continue" class="anchor"></a><code><span>| </span><span><span class="constructor">Continue</span> <span class="keyword">of</span> <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A continue to the start of the nearest enclosing <code>Loop</code></p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.If" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.If" class="anchor"></a><code><span>| </span><span><span class="constructor">If</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-block">block</a> * <a href="#type-block">block</a> * <a href="#type-location">location</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A conditional. Two successors, the &quot;then&quot; and the &quot;else&quot; branches. Both branches fall-through to the successor of the If statement. Second location is just for expression.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.Switch" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Switch" class="anchor"></a><code><span>| </span><span><span class="constructor">Switch</span> <span class="keyword">of</span> <a href="#type-exp">exp</a> * <a href="#type-block">block</a> * <span><a href="#type-stmt">stmt</a> list</span> * <a href="#type-location">location</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A switch statement. The statements that implement the cases can be reached through the provided list. For each such target you can find among its labels what cases it implements. The statements that implement the cases are somewhere within the provided <code>block</code>. Second location is just for expression.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.Loop" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Loop" class="anchor"></a><code><span>| </span><span><span class="constructor">Loop</span> <span class="keyword">of</span> <a href="#type-block">block</a> * <a href="#type-location">location</a> * <a href="#type-location">location</a> * <span><a href="#type-stmt">stmt</a> option</span> * <span><a href="#type-stmt">stmt</a> option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A <code>while(1)</code> loop. The termination test is implemented in the body of a loop using a <code>Break</code> statement. If prepareCFG has been called, the first stmt option will point to the stmt containing the continue label for this loop and the second will point to the stmt containing the break label for this loop. Second location is just for expression.</p><span class="comment-delim">*)</span></td></tr><tr id="type-stmtkind.Block" class="anchored"><td class="def variant constructor"><a href="#type-stmtkind.Block" class="anchor"></a><code><span>| </span><span><span class="constructor">Block</span> <span class="keyword">of</span> <a href="#type-block">block</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Just a block of statements. Use it as a way to keep some block attributes local</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>The various kinds of control-flow statements statements</p></div></div><p><b>Instructions</b>. An instruction <a href="#type-instr"><code>instr</code></a> is a statement that has no local (intraprocedural) control flow. It can be either an assignment, function call, or an inline assembly instruction.</p><div class="odoc-spec"><div class="spec type" id="type-instr" class="anchored"><a href="#type-instr" class="anchor"></a><code><span><span class="keyword">and</span> instr</span><span> = </span></code><table><tr id="type-instr.Set" class="anchored"><td class="def variant constructor"><a href="#type-instr.Set" class="anchor"></a><code><span>| </span><span><span class="constructor">Set</span> <span class="keyword">of</span> <a href="#type-lval">lval</a> * <a href="#type-exp">exp</a> * <a href="#type-location">location</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>An assignment. The type of the expression is guaranteed to be the same with that of the lvalue. Second location is just for expression when inside condition.</p><span class="comment-delim">*)</span></td></tr><tr id="type-instr.VarDecl" class="anchored"><td class="def variant constructor"><a href="#type-instr.VarDecl" class="anchor"></a><code><span>| </span><span><span class="constructor">VarDecl</span> <span class="keyword">of</span> <a href="#type-varinfo">varinfo</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>&quot;Instruction&quot; in the location where a varinfo was declared. All varinfos for which such a VarDecl instruction exists have vhasdeclinstruction set to true. The motivation for the addition of this instruction was to support VLAs for which declerations can not be pulled up like CIL used to do.</p><span class="comment-delim">*)</span></td></tr><tr id="type-instr.Call" class="anchored"><td class="def variant constructor"><a href="#type-instr.Call" class="anchor"></a><code><span>| </span><span><span class="constructor">Call</span> <span class="keyword">of</span> <span><a href="#type-lval">lval</a> option</span> * <a href="#type-exp">exp</a> * <span><a href="#type-exp">exp</a> list</span> * <a href="#type-location">location</a> * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>A function call with the (optional) result placed in an lval. It is possible that the returned type of the function is not identical to that of the lvalue. In that case a cast is printed. The type of the actual arguments are identical to those of the declared formals. The number of arguments is the same as that of the declared formals, except for vararg functions. This construct is also used to encode a call to &quot;__builtin_va_arg&quot;. In this case the second argument (which should be a type T) is encoded SizeOf(T). Second location is just for expression when inside condition.</p><span class="comment-delim">*)</span></td></tr><tr id="type-instr.Asm" class="anchored"><td class="def variant constructor"><a href="#type-instr.Asm" class="anchor"></a><code><span>| </span><span><span class="constructor">Asm</span> <span class="keyword">of</span> <a href="#type-attributes">attributes</a>
  * <span>string list</span>
  * <span><span>(<span>string option</span> * string * <a href="#type-lval">lval</a>)</span> list</span>
  * <span><span>(<span>string option</span> * string * <a href="#type-exp">exp</a>)</span> list</span>
  * <span>string list</span>
  * <a href="#type-location">location</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>There are for storing inline assembly. They follow the GCC specification:</p><pre>  asm [volatile] (&quot;...template...&quot; &quot;..template..&quot;
                  : &quot;c1&quot; (o1), &quot;c2&quot; (o2), ..., &quot;cN&quot; (oN)
                  : &quot;d1&quot; (i1), &quot;d2&quot; (i2), ..., &quot;dM&quot; (iM)
                  : &quot;r1&quot;, &quot;r2&quot;, ..., &quot;nL&quot; );</pre><p>where the parts are</p><ul><li><code>volatile</code> (optional): when present, the assembler instruction cannot be removed, moved, or otherwise optimized</li><li>template: a sequence of strings, with %0, %1, %2, etc. in the string to refer to the input and output expressions. I think they're numbered consecutively, but the docs don't specify. Each string is printed on a separate line.</li><li>&quot;ci&quot; (oi): pairs of constraint-string and output-lval; the constraint specifies that the register used must have some property, like being a floating-point register; the constraint string for outputs also has &quot;=&quot; to indicate it is written, or &quot;+&quot; to indicate it is both read and written; 'oi' is the name of a C lvalue (probably a variable name) to be used as the output destination</li><li>&quot;dj&quot; (ij): pairs of constraint and input expression; the constraint is similar to the &quot;ci&quot;s. the 'ij' is an arbitrary C expression to be loaded into the corresponding register</li><li>&quot;rk&quot;: registers to be regarded as &quot;clobbered&quot; by the instruction; &quot;memory&quot; may be specified for arbitrary memory effects</li></ul><p>an example (from gcc manual):</p><pre>  asm volatile (&quot;movc3 %0,%1,%2&quot;
                : /* no outputs */
                : &quot;g&quot; (from), &quot;g&quot; (to), &quot;g&quot; (count)
                : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r4&quot;, &quot;r5&quot;);</pre><p>Starting with gcc 3.1, the operands may have names:</p><pre>  asm volatile (&quot;movc3 %[in0],%1,%2&quot;
                : /* no outputs */
                : [in0] &quot;g&quot; (from), &quot;g&quot; (to), &quot;g&quot; (count)
                : &quot;r0&quot;, &quot;r1&quot;, &quot;r2&quot;, &quot;r3&quot;, &quot;r4&quot;, &quot;r5&quot;);</pre><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Instructions.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-location" class="anchored"><a href="#type-location" class="anchor"></a><code><span><span class="keyword">and</span> location</span><span> = </span><span>{</span></code><table><tr id="type-location.line" class="anchored"><td class="def record field"><a href="#type-location.line" class="anchor"></a><code><span>line : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The line number. -1 means &quot;do not know&quot;</p><span class="comment-delim">*)</span></td></tr><tr id="type-location.file" class="anchored"><td class="def record field"><a href="#type-location.file" class="anchor"></a><code><span>file : string;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The name of the source file</p><span class="comment-delim">*)</span></td></tr><tr id="type-location.byte" class="anchored"><td class="def record field"><a href="#type-location.byte" class="anchor"></a><code><span>byte : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The byte position in the source file</p><span class="comment-delim">*)</span></td></tr><tr id="type-location.column" class="anchored"><td class="def record field"><a href="#type-location.column" class="anchor"></a><code><span>column : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>The column number</p><span class="comment-delim">*)</span></td></tr><tr id="type-location.endLine" class="anchored"><td class="def record field"><a href="#type-location.endLine" class="anchor"></a><code><span>endLine : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>End line number. Negative means unknown.</p><span class="comment-delim">*)</span></td></tr><tr id="type-location.endByte" class="anchored"><td class="def record field"><a href="#type-location.endByte" class="anchor"></a><code><span>endByte : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>End byte position. Negative means unknown.</p><span class="comment-delim">*)</span></td></tr><tr id="type-location.endColumn" class="anchored"><td class="def record field"><a href="#type-location.endColumn" class="anchor"></a><code><span>endColumn : int;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>End column number. Negative means unknown.</p><span class="comment-delim">*)</span></td></tr><tr id="type-location.synthetic" class="anchored"><td class="def record field"><a href="#type-location.synthetic" class="anchor"></a><code><span>synthetic : bool;</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Synthetic location, doesn't necessarily precisely correspond to a location in original source code, e.g. due to CIL transformations.</p><ul class="at-tags"><li class="see"><span class="at-tag">see</span> <a href="https://github.com/goblint/cil/pull/98" class="value">https://github.com/goblint/cil/pull/98</a> <p>for some examples.</p></li></ul><span class="comment-delim">*)</span></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Describes a location in a source file.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-typsig" class="anchored"><a href="#type-typsig" class="anchor"></a><code><span><span class="keyword">and</span> typsig</span><span> = </span></code><table><tr id="type-typsig.TSArray" class="anchored"><td class="def variant constructor"><a href="#type-typsig.TSArray" class="anchor"></a><code><span>| </span><span><span class="constructor">TSArray</span> <span class="keyword">of</span> <a href="#type-typsig">typsig</a> * <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> option</span> * <span><a href="#type-attribute">attribute</a> list</span></span></code></td></tr><tr id="type-typsig.TSPtr" class="anchored"><td class="def variant constructor"><a href="#type-typsig.TSPtr" class="anchor"></a><code><span>| </span><span><span class="constructor">TSPtr</span> <span class="keyword">of</span> <a href="#type-typsig">typsig</a> * <span><a href="#type-attribute">attribute</a> list</span></span></code></td></tr><tr id="type-typsig.TSComp" class="anchored"><td class="def variant constructor"><a href="#type-typsig.TSComp" class="anchor"></a><code><span>| </span><span><span class="constructor">TSComp</span> <span class="keyword">of</span> bool * string * <span><a href="#type-attribute">attribute</a> list</span></span></code></td></tr><tr id="type-typsig.TSFun" class="anchored"><td class="def variant constructor"><a href="#type-typsig.TSFun" class="anchor"></a><code><span>| </span><span><span class="constructor">TSFun</span> <span class="keyword">of</span> <a href="#type-typsig">typsig</a> * <span><span><a href="#type-typsig">typsig</a> list</span> option</span> * bool * <span><a href="#type-attribute">attribute</a> list</span></span></code></td></tr><tr id="type-typsig.TSEnum" class="anchored"><td class="def variant constructor"><a href="#type-typsig.TSEnum" class="anchor"></a><code><span>| </span><span><span class="constructor">TSEnum</span> <span class="keyword">of</span> string * <span><a href="#type-attribute">attribute</a> list</span></span></code></td></tr><tr id="type-typsig.TSBase" class="anchored"><td class="def variant constructor"><a href="#type-typsig.TSBase" class="anchor"></a><code><span>| </span><span><span class="constructor">TSBase</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code></td></tr></table></div><div class="spec-doc"><p>Type signatures. Two types are identical iff they have identical signatures. These contain the same information as types but canonicalized. For example, two function types that are identical except for the name of the formal arguments are given the same signature. Also, <code>TNamed</code> constructors are unrolled.</p></div></div><p><b>Lowering Options</b></p><div class="odoc-spec"><div class="spec value" id="val-lowerConstants" class="anchored"><a href="#val-lowerConstants" class="anchor"></a><code><span><span class="keyword">val</span> lowerConstants : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Do lower constants (default true)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-removeBranchingOnConstants" class="anchored"><a href="#val-removeBranchingOnConstants" class="anchor"></a><code><span><span class="keyword">val</span> removeBranchingOnConstants : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Remove branches of the form if(const) ... else ... (default true)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-insertImplicitCasts" class="anchored"><a href="#val-insertImplicitCasts" class="anchor"></a><code><span><span class="keyword">val</span> insertImplicitCasts : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Do insert implicit casts (default true)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compareLoc" class="anchored"><a href="#val-compareLoc" class="anchor"></a><code><span><span class="keyword">val</span> compareLoc : <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Comparison function for locations. Compares first by filename, then line, then byte</p></div></div><p><b>Values for manipulating globals</b></p><div class="odoc-spec"><div class="spec value" id="val-emptyFunction" class="anchored"><a href="#val-emptyFunction" class="anchor"></a><code><span><span class="keyword">val</span> emptyFunction : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-fundec">fundec</a></span></code></div><div class="spec-doc"><p>Make an empty function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-setFormals" class="anchored"><a href="#val-setFormals" class="anchor"></a><code><span><span class="keyword">val</span> setFormals : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-varinfo">varinfo</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Update the formals of a <code>fundec</code> and make sure that the function type has the same information. Will copy the name as well into the type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-setFunctionType" class="anchored"><a href="#val-setFunctionType" class="anchor"></a><code><span><span class="keyword">val</span> setFunctionType : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Set the types of arguments and results as given by the function type passed as the second argument. Will not copy the names from the function type to the formals</p></div></div><div class="odoc-spec"><div class="spec value" id="val-setFunctionTypeMakeFormals" class="anchored"><a href="#val-setFunctionTypeMakeFormals" class="anchor"></a><code><span><span class="keyword">val</span> setFunctionTypeMakeFormals : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Set the type of the function and make formal arguments for them</p></div></div><div class="odoc-spec"><div class="spec value" id="val-setMaxId" class="anchored"><a href="#val-setMaxId" class="anchor"></a><code><span><span class="keyword">val</span> setMaxId : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Update the smaxid after you have populated with locals and formals (unless you constructed those using <a href="#val-makeLocalVar"><code>makeLocalVar</code></a> or <a href="#val-makeTempVar"><code>makeTempVar</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dummyFunDec" class="anchored"><a href="#val-dummyFunDec" class="anchor"></a><code><span><span class="keyword">val</span> dummyFunDec : <a href="#type-fundec">fundec</a></span></code></div><div class="spec-doc"><p>A dummy function declaration handy when you need one as a placeholder. It contains inside a dummy varinfo.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dummyFile" class="anchored"><a href="#val-dummyFile" class="anchor"></a><code><span><span class="keyword">val</span> dummyFile : <a href="#type-file">file</a></span></code></div><div class="spec-doc"><p>A dummy file</p></div></div><div class="odoc-spec"><div class="spec value" id="val-saveBinaryFile" class="anchored"><a href="#val-saveBinaryFile" class="anchor"></a><code><span><span class="keyword">val</span> saveBinaryFile : <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write a <a href="#type-file"><code>file</code></a> in binary form to the filesystem. The file can be read back in later using <a href="#val-loadBinaryFile"><code>loadBinaryFile</code></a>, possibly saving parsing time. The second argument is the name of the file that should be created.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-saveBinaryFileChannel" class="anchored"><a href="#val-saveBinaryFileChannel" class="anchor"></a><code><span><span class="keyword">val</span> saveBinaryFileChannel : <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Write a <a href="#type-file"><code>file</code></a> in binary form to the filesystem. The file can be read back in later using <a href="#val-loadBinaryFile"><code>loadBinaryFile</code></a>, possibly saving parsing time. Does not close the channel.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-loadBinaryFile" class="anchored"><a href="#val-loadBinaryFile" class="anchor"></a><code><span><span class="keyword">val</span> loadBinaryFile : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-file">file</a></span></code></div><div class="spec-doc"><p>Read a <a href="#type-file"><code>file</code></a> in binary form from the filesystem. The first argument is the name of a file previously created by <a href="#val-saveBinaryFile"><code>saveBinaryFile</code></a>. Because this also reads some global state, this should be called before any other CIL code is parsed or generated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getGlobInit" class="anchored"><a href="#val-getGlobInit" class="anchor"></a><code><span><span class="keyword">val</span> getGlobInit : <span>?main_name:string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-fundec">fundec</a></span></code></div><div class="spec-doc"><p>Get the global initializer and create one if it does not already exist. When it creates a global initializer it attempts to place a call to it in the main function named by the optional argument (default &quot;main&quot;)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-iterGlobals" class="anchored"><a href="#val-iterGlobals" class="anchor"></a><code><span><span class="keyword">val</span> iterGlobals : <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> unit )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Iterate over all globals, including the global initializer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldGlobals" class="anchored"><a href="#val-foldGlobals" class="anchor"></a><code><span><span class="keyword">val</span> foldGlobals : <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold over all globals, including the global initializer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapGlobals" class="anchored"><a href="#val-mapGlobals" class="anchor"></a><code><span><span class="keyword">val</span> mapGlobals : <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> <span><span>( <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-global">global</a> )</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Map over all globals, including the global initializer and change things in place</p></div></div><div class="odoc-spec"><div class="spec value" id="val-findOrCreateFunc" class="anchored"><a href="#val-findOrCreateFunc" class="anchor"></a><code><span><span class="keyword">val</span> findOrCreateFunc : <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Find a function or function prototype with the given name in the file. If it does not exist, create a prototype with the given type, and return the new varinfo. This is useful when you need to call a libc function whose prototype may or may not already exist in the file.</p><p>Because the new prototype is added to the start of the file, you shouldn't refer to any struct or union types in the function type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-new_sid" class="anchored"><a href="#val-new_sid" class="anchor"></a><code><span><span class="keyword">val</span> new_sid : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-prepareCFG" class="anchored"><a href="#val-prepareCFG" class="anchor"></a><code><span><span class="keyword">val</span> prepareCFG : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Prepare a function for CFG information computation by <a href="#val-computeCFGInfo"><code>computeCFGInfo</code></a>. This function converts all <code>Break</code>, <code>Switch</code>, <code>Default</code> and <code>Continue</code> <a href="#type-stmtkind"><code>stmtkind</code></a>s and <a href="#type-label"><code>label</code></a>s into <code>If</code>s and <code>Goto</code>s, giving the function body a very CFG-like character. This function modifies its argument in place.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-computeCFGInfo" class="anchored"><a href="#val-computeCFGInfo" class="anchor"></a><code><span><span class="keyword">val</span> computeCFGInfo : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Compute the CFG information for all statements in a fundec and return a list of the statements. The input fundec cannot have <code>Break</code>, <code>Switch</code>, <code>Default</code>, or <code>Continue</code> <a href="#type-stmtkind"><code>stmtkind</code></a>s or <a href="#type-label"><code>label</code></a>s. Use <a href="#val-prepareCFG"><code>prepareCFG</code></a> to transform them away. The second argument should be <code>true</code> if you wish a global statement number, <code>false</code> if you wish a local (per-function) statement numbering. The list of statements is set in the sallstmts field of a fundec.</p><p>NOTE: unless you want the simpler control-flow graph provided by prepareCFG, or you need the function's smaxstmtid and sallstmt fields filled in, we recommend you use <a href="Cfg/index.html#val-computeFileCFG"><code>Cfg.computeFileCFG</code></a> instead of this function to compute control-flow information. <a href="Cfg/index.html#val-computeFileCFG"><code>Cfg.computeFileCFG</code></a> is newer and will handle switch, break, and continue correctly.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-copyFunction" class="anchored"><a href="#val-copyFunction" class="anchor"></a><code><span><span class="keyword">val</span> copyFunction : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-fundec">fundec</a></span></code></div><div class="spec-doc"><p>Create a deep copy of a function. There should be no sharing between the copy and the original function</p></div></div><div class="odoc-spec"><div class="spec value" id="val-pushGlobal" class="anchored"><a href="#val-pushGlobal" class="anchor"></a><code><span><span class="keyword">val</span> pushGlobal : 
  <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span>
  <span>types:<span><span><a href="#type-global">global</a> list</span> <span class="xref-unresolved">Stdlib</span>.ref</span> <span class="arrow">&#45;&gt;</span></span>
  <span>variables:<span><span><a href="#type-global">global</a> list</span> <span class="xref-unresolved">Stdlib</span>.ref</span> <span class="arrow">&#45;&gt;</span></span>
  unit</span></code></div><div class="spec-doc"><p>CIL keeps the types at the beginning of the file and the variables at the end of the file. This function will take a global and add it to the corresponding stack. Its operation is actually more complicated because if the global declares a type that contains references to variables (e.g. in sizeof in an array length) then it will also add declarations for the variables to the types stack</p></div></div><div class="odoc-spec"><div class="spec value" id="val-invalidStmt" class="anchored"><a href="#val-invalidStmt" class="anchor"></a><code><span><span class="keyword">val</span> invalidStmt : <a href="#type-stmt">stmt</a></span></code></div><div class="spec-doc"><p>An empty statement. Used in pretty printing</p></div></div><div class="odoc-spec"><div class="spec value" id="val-builtinFunctions" class="anchored"><a href="#val-builtinFunctions" class="anchor"></a><code><span><span class="keyword">val</span> builtinFunctions : <span><span>( string, <a href="#type-typ">typ</a> * <span><a href="#type-typ">typ</a> list</span> * bool )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span></span></code></div><div class="spec-doc"><p>A list of the built-in functions for the current compiler. Maps the name to the result and argument types, and whether it is vararg. Initialized by <a href="#val-initCIL"><code>initCIL</code></a></p><p>This map replaces <code>gccBuiltins</code> and <code>msvcBuiltins</code> in previous versions of CIL.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-builtinLoc" class="anchored"><a href="#val-builtinLoc" class="anchor"></a><code><span><span class="keyword">val</span> builtinLoc : <a href="#type-location">location</a></span></code></div><div class="spec-doc"><p>This is used as the location of the prototypes of builtin functions.</p></div></div><p><b>Values for manipulating initializers</b></p><div class="odoc-spec"><div class="spec value" id="val-makeZeroInit" class="anchored"><a href="#val-makeZeroInit" class="anchor"></a><code><span><span class="keyword">val</span> makeZeroInit : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-init">init</a></span></code></div><div class="spec-doc"><p>Make a initializer for zero-ing a data type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-foldLeftCompound" class="anchored"><a href="#val-foldLeftCompound" class="anchor"></a><code><span><span class="keyword">val</span> foldLeftCompound : 
  <span>implicit:bool <span class="arrow">&#45;&gt;</span></span>
  <span>doinit:<span>( <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span>ct:<a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span>
  <span>initl:<span><span>(<a href="#type-offset">offset</a> * <a href="#type-init">init</a>)</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>acc:<span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span>
  <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Fold over the list of initializers in a Compound (not also the nested ones). <code>doinit</code> is called on every present initializer, even if it is of compound type. The parameters of <code>doinit</code> are: the offset in the compound (this is <code>Field(f,NoOffset)</code> or <code>Index(i,NoOffset)</code>), the initializer value, expected type of the initializer value, accumulator. In the case of arrays there might be missing zero-initializers at the end of the list. These are scanned only if <code>implicit</code> is true. This is much like <code>List.fold_left</code> except we also pass the type of the initializer.</p><p>This is a good way to use it to scan even nested initializers :</p><pre>  let rec myInit (lv: lval) (i: init) (acc: 'a) : 'a =
      match i with
        SingleInit e -&gt; ... do something with lv and e and acc ...
      | CompoundInit (ct, initl) -&gt;
         foldLeftCompound ~implicit:false
             ~doinit:(fun off' i' t' acc -&gt;
                        myInit (addOffsetLval lv off') i' acc)
             ~ct:ct
             ~initl:initl
             ~acc:acc</pre></div></div><p><b>Values for manipulating types</b></p><div class="odoc-spec"><div class="spec value" id="val-voidType" class="anchored"><a href="#val-voidType" class="anchor"></a><code><span><span class="keyword">val</span> voidType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>void</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isVoidType" class="anchored"><a href="#val-isVoidType" class="anchor"></a><code><span><span class="keyword">val</span> isVoidType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>is the given type &quot;void&quot;?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isVoidPtrType" class="anchored"><a href="#val-isVoidPtrType" class="anchor"></a><code><span><span class="keyword">val</span> isVoidPtrType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>is the given type &quot;void *&quot;?</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeOfRealAndImagComponents" class="anchored"><a href="#val-typeOfRealAndImagComponents" class="anchor"></a><code><span><span class="keyword">val</span> typeOfRealAndImagComponents : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>for numerical __complex types return type of corresponding real part and imaginary parts</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getComplexFkind" class="anchored"><a href="#val-getComplexFkind" class="anchor"></a><code><span><span class="keyword">val</span> getComplexFkind : <span><a href="#type-fkind">fkind</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-fkind">fkind</a></span></code></div><div class="spec-doc"><p>for an fkind, return the corresponding complex fkind</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intType" class="anchored"><a href="#val-intType" class="anchor"></a><code><span><span class="keyword">val</span> intType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>int</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uintType" class="anchored"><a href="#val-uintType" class="anchor"></a><code><span><span class="keyword">val</span> uintType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>unsigned int</p></div></div><div class="odoc-spec"><div class="spec value" id="val-longType" class="anchored"><a href="#val-longType" class="anchor"></a><code><span><span class="keyword">val</span> longType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>long</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ulongType" class="anchored"><a href="#val-ulongType" class="anchor"></a><code><span><span class="keyword">val</span> ulongType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>unsigned long</p></div></div><div class="odoc-spec"><div class="spec value" id="val-charType" class="anchored"><a href="#val-charType" class="anchor"></a><code><span><span class="keyword">val</span> charType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>char</p></div></div><div class="odoc-spec"><div class="spec value" id="val-charPtrType" class="anchored"><a href="#val-charPtrType" class="anchor"></a><code><span><span class="keyword">val</span> charPtrType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>char *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stringLiteralType" class="anchored"><a href="#val-stringLiteralType" class="anchor"></a><code><span><span class="keyword">val</span> stringLiteralType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Type of string literals</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wcharKind" class="anchored"><a href="#val-wcharKind" class="anchor"></a><code><span><span class="keyword">val</span> wcharKind : <span><a href="#type-ikind">ikind</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>wchar_t, char16_t and char32_t depend on architecture and are set when you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-wcharType" class="anchored"><a href="#val-wcharType" class="anchor"></a><code><span><span class="keyword">val</span> wcharType : <span><a href="#type-typ">typ</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-char16Kind" class="anchored"><a href="#val-char16Kind" class="anchor"></a><code><span><span class="keyword">val</span> char16Kind : <span><a href="#type-ikind">ikind</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-char16Type" class="anchored"><a href="#val-char16Type" class="anchor"></a><code><span><span class="keyword">val</span> char16Type : <span><a href="#type-typ">typ</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-char32Kind" class="anchored"><a href="#val-char32Kind" class="anchor"></a><code><span><span class="keyword">val</span> char32Kind : <span><a href="#type-ikind">ikind</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-char32Type" class="anchored"><a href="#val-char32Type" class="anchor"></a><code><span><span class="keyword">val</span> char32Type : <span><a href="#type-typ">typ</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-charConstPtrType" class="anchored"><a href="#val-charConstPtrType" class="anchor"></a><code><span><span class="keyword">val</span> charConstPtrType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>char const *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-voidPtrType" class="anchored"><a href="#val-voidPtrType" class="anchor"></a><code><span><span class="keyword">val</span> voidPtrType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>void *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intPtrType" class="anchored"><a href="#val-intPtrType" class="anchor"></a><code><span><span class="keyword">val</span> intPtrType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>int *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-uintPtrType" class="anchored"><a href="#val-uintPtrType" class="anchor"></a><code><span><span class="keyword">val</span> uintPtrType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>unsigned int *</p></div></div><div class="odoc-spec"><div class="spec value" id="val-doubleType" class="anchored"><a href="#val-doubleType" class="anchor"></a><code><span><span class="keyword">val</span> doubleType : <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>double</p></div></div><div class="odoc-spec"><div class="spec value" id="val-upointType" class="anchored"><a href="#val-upointType" class="anchor"></a><code><span><span class="keyword">val</span> upointType : <span><a href="#type-typ">typ</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>An unsigned integer type that fits pointers. Is set when you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-ptrdiffType" class="anchored"><a href="#val-ptrdiffType" class="anchor"></a><code><span><span class="keyword">val</span> ptrdiffType : <span><a href="#type-typ">typ</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>An signed integer type that fits pointer difference. Is set when you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeOfSizeOf" class="anchored"><a href="#val-typeOfSizeOf" class="anchor"></a><code><span><span class="keyword">val</span> typeOfSizeOf : <span><a href="#type-typ">typ</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>An unsigned integer type that is the type of sizeof. Is set when you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kindOfSizeOf" class="anchored"><a href="#val-kindOfSizeOf" class="anchor"></a><code><span><span class="keyword">val</span> kindOfSizeOf : <span><a href="#type-ikind">ikind</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>The integer kind of <a href="#val-typeOfSizeOf"><code>typeOfSizeOf</code></a>. Set when you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isSigned" class="anchored"><a href="#val-isSigned" class="anchor"></a><code><span><span class="keyword">val</span> isSigned : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if and only if the given integer type is signed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCompInfo" class="anchored"><a href="#val-mkCompInfo" class="anchor"></a><code><span><span class="keyword">val</span> mkCompInfo : 
  <span>bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="#type-compinfo">compinfo</a> <span class="arrow">&#45;&gt;</span></span> <span><span>(string * <a href="#type-typ">typ</a> * <span>int option</span> * <a href="#type-attributes">attributes</a> * <a href="#type-location">location</a>)</span> list</span> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-compinfo">compinfo</a></span></code></div><div class="spec-doc"><p>Creates a a (potentially recursive) composite type. The arguments are: (1) a boolean indicating whether it is a struct or a union, (2) the name (always non-empty), (3) a function that when given a representation of the structure type constructs the type of the fields recursive type (the first argument is only useful when some fields need to refer to the type of the structure itself), and (4) a list of attributes to be associated with the composite type. The resulting compinfo has the field &quot;cdefined&quot; only if the list of fields is non-empty.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-copyCompInfo" class="anchored"><a href="#val-copyCompInfo" class="anchor"></a><code><span><span class="keyword">val</span> copyCompInfo : <span><a href="#type-compinfo">compinfo</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-compinfo">compinfo</a></span></code></div><div class="spec-doc"><p>Makes a shallow copy of a <a href="#type-compinfo"><code>compinfo</code></a> changing the name and the key.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-missingFieldName" class="anchored"><a href="#val-missingFieldName" class="anchor"></a><code><span><span class="keyword">val</span> missingFieldName : string</span></code></div><div class="spec-doc"><p>This is a constant used as the name of an unnamed bitfield. These fields do not participate in initialization and their name is not printed.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compFullName" class="anchored"><a href="#val-compFullName" class="anchor"></a><code><span><span class="keyword">val</span> compFullName : <span><a href="#type-compinfo">compinfo</a> <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Get the full name of a comp</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isCompleteType" class="anchored"><a href="#val-isCompleteType" class="anchor"></a><code><span><span class="keyword">val</span> isCompleteType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Returns true if this is a complete type. This means that sizeof(t) makes sense. Incomplete types are not yet defined structures and empty arrays.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unrollType" class="anchored"><a href="#val-unrollType" class="anchor"></a><code><span><span class="keyword">val</span> unrollType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Unroll a type until it exposes a non <code>TNamed</code>. Will collect all attributes appearing in <code>TNamed</code>!!!</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unrollTypeDeep" class="anchored"><a href="#val-unrollTypeDeep" class="anchor"></a><code><span><span class="keyword">val</span> unrollTypeDeep : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Unroll all the TNamed in a type (even under type constructors such as <code>TPtr</code>, <code>TFun</code> or <code>TArray</code>. Does not unroll the types of fields in <code>TComp</code> types. Will collect all attributes</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isIntegralType" class="anchored"><a href="#val-isIntegralType" class="anchor"></a><code><span><span class="keyword">val</span> isIntegralType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the argument is an integral type (i.e. integer or enum)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isArithmeticType" class="anchored"><a href="#val-isArithmeticType" class="anchor"></a><code><span><span class="keyword">val</span> isArithmeticType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the argument is an arithmetic type (i.e. integer, enum or floating point</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isPointerType" class="anchored"><a href="#val-isPointerType" class="anchor"></a><code><span><span class="keyword">val</span> isPointerType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the argument is a pointer type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isScalarType" class="anchored"><a href="#val-isScalarType" class="anchor"></a><code><span><span class="keyword">val</span> isScalarType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the argument is a scalar type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isFunctionType" class="anchored"><a href="#val-isFunctionType" class="anchor"></a><code><span><span class="keyword">val</span> isFunctionType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the argument is a function type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-argsToList" class="anchored"><a href="#val-argsToList" class="anchor"></a><code><span><span class="keyword">val</span> argsToList : 
  <span><span><span><span>(string * <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a>)</span> list</span> option</span> <span class="arrow">&#45;&gt;</span></span>
  <span><span>(string * <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a>)</span> list</span></span></code></div><div class="spec-doc"><p>Obtain the argument list ( if None)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isArrayType" class="anchored"><a href="#val-isArrayType" class="anchor"></a><code><span><span class="keyword">val</span> isArrayType : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the argument is an array type</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-LenOfArray" class="anchored"><a href="#exception-LenOfArray" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">LenOfArray</span></span></code></div><div class="spec-doc"><p>Raised when <a href="#val-lenOfArray"><code>lenOfArray</code></a> fails either because the length is <code>None</code> or because it is a non-constant expression</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lenOfArray" class="anchored"><a href="#val-lenOfArray" class="anchor"></a><code><span><span class="keyword">val</span> lenOfArray : <span><span><a href="#type-exp">exp</a> option</span> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Call to compute the array length as present in the array type, to an integer. Raises <a href="#exception-LenOfArray"><code>LenOfArray</code></a> if not able to compute the length, such as when there is no length or the length is not a constant.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getCompField" class="anchored"><a href="#val-getCompField" class="anchor"></a><code><span><span class="keyword">val</span> getCompField : <span><a href="#type-compinfo">compinfo</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-fieldinfo">fieldinfo</a></span></code></div><div class="spec-doc"><p>Return a named fieldinfo in compinfo, or raise Not_found</p></div></div><div class="odoc-spec"><div class="spec type" id="type-existsAction" class="anchored"><a href="#type-existsAction" class="anchor"></a><code><span><span class="keyword">type</span> existsAction</span><span> = </span></code><table><tr id="type-existsAction.ExistsTrue" class="anchored"><td class="def variant constructor"><a href="#type-existsAction.ExistsTrue" class="anchor"></a><code><span>| </span><span><span class="constructor">ExistsTrue</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>We have found it</p><span class="comment-delim">*)</span></td></tr><tr id="type-existsAction.ExistsFalse" class="anchored"><td class="def variant constructor"><a href="#type-existsAction.ExistsFalse" class="anchor"></a><code><span>| </span><span><span class="constructor">ExistsFalse</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Stop processing this branch</p><span class="comment-delim">*)</span></td></tr><tr id="type-existsAction.ExistsMaybe" class="anchored"><td class="def variant constructor"><a href="#type-existsAction.ExistsMaybe" class="anchor"></a><code><span>| </span><span><span class="constructor">ExistsMaybe</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>This node is not what we are looking for but maybe its successors are</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>A datatype to be used in conjunction with <code>existsType</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-existsType" class="anchored"><a href="#val-existsType" class="anchor"></a><code><span><span class="keyword">val</span> existsType : <span><span>( <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-existsAction">existsAction</a> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>Scans a type by applying the function on all elements. When the function returns ExistsTrue, the scan stops with true. When the function returns ExistsFalse then the current branch is not scanned anymore. Care is taken to apply the function only once on each composite type, thus avoiding circularity. When the function returns ExistsMaybe then the types that construct the current type are scanned (e.g. the base type for TPtr and TArray, the type of fields for a TComp, etc).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-splitFunctionType" class="anchored"><a href="#val-splitFunctionType" class="anchor"></a><code><span><span class="keyword">val</span> splitFunctionType : 
  <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-typ">typ</a> * <span><span><span>(string * <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a>)</span> list</span> option</span> * bool * <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Given a function type split it into return type, arguments, is_vararg and attributes. An error is raised if the type is not a function type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-splitFunctionTypeVI" class="anchored"><a href="#val-splitFunctionTypeVI" class="anchor"></a><code><span><span class="keyword">val</span> splitFunctionTypeVI : 
  <span><a href="#type-varinfo">varinfo</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-typ">typ</a> * <span><span><span>(string * <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a>)</span> list</span> option</span> * bool * <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Same as <a href="#val-splitFunctionType"><code>splitFunctionType</code></a> but takes a varinfo. Prints a nicer error message if the varinfo is not for a function</p></div></div><p><b>Type signatures</b></p><p>Type signatures. Two types are identical iff they have identical signatures. These contain the same information as types but canonicalized. For example, two function types that are identical except for the name of the formal arguments are given the same signature. Also, <code>TNamed</code> constructors are unrolled.</p><div class="odoc-spec"><div class="spec value" id="val-d_typsig" class="anchored"><a href="#val-d_typsig" class="anchor"></a><code><span><span class="keyword">val</span> d_typsig : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typsig">typsig</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print a type signature</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeSig" class="anchored"><a href="#val-typeSig" class="anchor"></a><code><span><span class="keyword">val</span> typeSig : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typsig">typsig</a></span></code></div><div class="spec-doc"><p>Compute a type signature</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeSigWithAttrs" class="anchored"><a href="#val-typeSigWithAttrs" class="anchor"></a><code><span><span class="keyword">val</span> typeSigWithAttrs : 
  <span>?ignoreSign:bool <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attributes">attributes</a> )</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-typsig">typsig</a></span></code></div><div class="spec-doc"><p>Like <a href="#val-typeSig"><code>typeSig</code></a> but customize the incorporation of attributes. Use ~ignoreSign:true to convert all signed integer types to unsigned, so that signed and unsigned will compare the same.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-setTypeSigAttrs" class="anchored"><a href="#val-setTypeSigAttrs" class="anchor"></a><code><span><span class="keyword">val</span> setTypeSigAttrs : <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typsig">typsig</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typsig">typsig</a></span></code></div><div class="spec-doc"><p>Replace the attributes of a signature (only at top level)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeSigAttrs" class="anchored"><a href="#val-typeSigAttrs" class="anchor"></a><code><span><span class="keyword">val</span> typeSigAttrs : <span><a href="#type-typsig">typsig</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Get the top-level attributes of a signature</p></div></div><p><b>Lvalues</b></p><div class="odoc-spec"><div class="spec value" id="val-makeVarinfo" class="anchored"><a href="#val-makeVarinfo" class="anchor"></a><code><span><span class="keyword">val</span> makeVarinfo : <span>bool <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span>?init:<a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Make a varinfo. Use this (rarely) to make a raw varinfo. Use other functions to make locals (<a href="#val-makeLocalVar"><code>makeLocalVar</code></a> or <a href="#val-makeFormalVar"><code>makeFormalVar</code></a> or <a href="#val-makeTempVar"><code>makeTempVar</code></a>) and globals (<a href="#val-makeGlobalVar"><code>makeGlobalVar</code></a>). Note that this function will assign a new identifier. The first argument specifies whether the varinfo is for a global.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-makeFormalVar" class="anchored"><a href="#val-makeFormalVar" class="anchor"></a><code><span><span class="keyword">val</span> makeFormalVar : <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> <span>?where:string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Make a formal variable for a function. Insert it in both the sformals and the type of the function. You can optionally specify where to insert this one. If where = &quot;^&quot; then it is inserted first. If where = &quot;$&quot; then it is inserted last. Otherwise where must be the name of a formal after which to insert this. By default it is inserted at the end.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-makeLocalVar" class="anchored"><a href="#val-makeLocalVar" class="anchor"></a><code><span><span class="keyword">val</span> makeLocalVar : 
  <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?insert:bool <span class="arrow">&#45;&gt;</span></span>
  <span>string <span class="arrow">&#45;&gt;</span></span>
  <span>?init:<a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Make a local variable and add it to a function's slocals (only if insert = true, which is the default). Make sure you know what you are doing if you set insert=false.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-makeTempVar" class="anchored"><a href="#val-makeTempVar" class="anchor"></a><code><span><span class="keyword">val</span> makeTempVar : 
  <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?insert:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?name:string <span class="arrow">&#45;&gt;</span></span>
  <span>?descr:<a href="Pretty/index.html#type-doc">Pretty.doc</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?descrpure:bool <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Make a temporary variable and add it to a function's slocals. CIL will ensure that the name of the new variable is unique in this function, and will generate this name by appending a number to the specified string (&quot;__cil_tmp&quot; by default).</p><p>The variable will be added to the function's slocals unless you explicitly set insert=false. (Make sure you know what you are doing if you set insert=false.)</p><p>Optionally, you can give the variable a description of its contents that will be printed by descriptiveCilPrinter.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-makeGlobalVar" class="anchored"><a href="#val-makeGlobalVar" class="anchor"></a><code><span><span class="keyword">val</span> makeGlobalVar : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Make a global variable. Your responsibility to make sure that the name is unique</p></div></div><div class="odoc-spec"><div class="spec value" id="val-copyVarinfo" class="anchored"><a href="#val-copyVarinfo" class="anchor"></a><code><span><span class="keyword">val</span> copyVarinfo : <span><a href="#type-varinfo">varinfo</a> <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Make a shallow copy of a <code>varinfo</code> and assign a new identifier</p></div></div><div class="odoc-spec"><div class="spec value" id="val-newVID" class="anchored"><a href="#val-newVID" class="anchor"></a><code><span><span class="keyword">val</span> newVID : <span>unit <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Generate a new variable ID. This will be different than any variable ID that is generated by <a href="#val-makeLocalVar"><code>makeLocalVar</code></a> and friends</p></div></div><div class="odoc-spec"><div class="spec value" id="val-addOffsetLval" class="anchored"><a href="#val-addOffsetLval" class="anchor"></a><code><span><span class="keyword">val</span> addOffsetLval : <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lval">lval</a></span></code></div><div class="spec-doc"><p>Add an offset at the end of an lvalue. Make sure the type of the lvalue and the offset are compatible.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-addOffset" class="anchored"><a href="#val-addOffset" class="anchor"></a><code><span><span class="keyword">val</span> addOffset : <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-offset">offset</a></span></code></div><div class="spec-doc"><p><code>addOffset o1 o2</code> adds <code>o1</code> to the end of <code>o2</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-removeOffsetLval" class="anchored"><a href="#val-removeOffsetLval" class="anchor"></a><code><span><span class="keyword">val</span> removeOffsetLval : <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lval">lval</a> * <a href="#type-offset">offset</a></span></code></div><div class="spec-doc"><p>Remove ONE offset from the end of an lvalue. Returns the lvalue with the trimmed offset and the final offset. If the final offset is <code>NoOffset</code> then the original <code>lval</code> did not have an offset.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-removeOffset" class="anchored"><a href="#val-removeOffset" class="anchor"></a><code><span><span class="keyword">val</span> removeOffset : <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-offset">offset</a> * <a href="#type-offset">offset</a></span></code></div><div class="spec-doc"><p>Remove ONE offset from the end of an offset sequence. Returns the trimmed offset and the final offset. If the final offset is <code>NoOffset</code> then the original <code>lval</code> did not have an offset.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeOfLval" class="anchored"><a href="#val-typeOfLval" class="anchor"></a><code><span><span class="keyword">val</span> typeOfLval : <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Compute the type of an lvalue</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeOffset" class="anchored"><a href="#val-typeOffset" class="anchor"></a><code><span><span class="keyword">val</span> typeOffset : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Compute the type of an offset from a base type</p></div></div><p><b>Values for manipulating expressions</b></p><div class="odoc-spec"><div class="spec value" id="val-zero" class="anchored"><a href="#val-zero" class="anchor"></a><code><span><span class="keyword">val</span> zero : <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>0</p></div></div><div class="odoc-spec"><div class="spec value" id="val-one" class="anchored"><a href="#val-one" class="anchor"></a><code><span><span class="keyword">val</span> one : <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>1</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mone" class="anchored"><a href="#val-mone" class="anchor"></a><code><span><span class="keyword">val</span> mone : <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>-1</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kintegerCilint" class="anchored"><a href="#val-kintegerCilint" class="anchor"></a><code><span><span class="keyword">val</span> kintegerCilint : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Construct an integer of a given kind, from a cilint. If needed it will truncate the integer to be within the representable range for the given kind.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kinteger64" class="anchored"><a href="#val-kinteger64" class="anchor"></a><code><span><span class="keyword">val</span> kinteger64 : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Construct an integer of a given kind, using OCaml's int64 type. If needed it will truncate the integer to be within the representable range for the given kind.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-kinteger" class="anchored"><a href="#val-kinteger" class="anchor"></a><code><span><span class="keyword">val</span> kinteger : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Construct an integer of a given kind. Converts the integer to int64 and then uses kinteger64. This might truncate the value if you use a kind that cannot represent the given integer. This can only happen for one of the Char or Short kinds</p></div></div><div class="odoc-spec"><div class="spec value" id="val-integer" class="anchored"><a href="#val-integer" class="anchor"></a><code><span><span class="keyword">val</span> integer : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Construct an integer of kind IInt. On targets where C's 'int' is 16-bits, the integer may get truncated.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-getInteger" class="anchored"><a href="#val-getInteger" class="anchor"></a><code><span><span class="keyword">val</span> getInteger : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> option</span></span></code></div><div class="spec-doc"><p>If the given expression is an integer constant or a CastE'd integer constant, return that constant's value. Otherwise return None.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-i64_to_int" class="anchored"><a href="#val-i64_to_int" class="anchor"></a><code><span><span class="keyword">val</span> i64_to_int : <span>int64 <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Convert a 64-bit int to an OCaml int, or raise an exception if that can't be done.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-cilint_to_int" class="anchored"><a href="#val-cilint_to_int" class="anchor"></a><code><span><span class="keyword">val</span> cilint_to_int : <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Convert a cilint int to an OCaml int, or raise an exception if that can't be done.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isConstant" class="anchored"><a href="#val-isConstant" class="anchor"></a><code><span><span class="keyword">val</span> isConstant : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the expression is a compile-time constant</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isConstantOffset" class="anchored"><a href="#val-isConstantOffset" class="anchor"></a><code><span><span class="keyword">val</span> isConstantOffset : <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the given offset contains only field nanmes or constant indices.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isZero" class="anchored"><a href="#val-isZero" class="anchor"></a><code><span><span class="keyword">val</span> isZero : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the given expression is a (possibly cast'ed) integer or character constant with value zero</p></div></div><div class="odoc-spec"><div class="spec value" id="val-isNullPtrConstant" class="anchored"><a href="#val-isNullPtrConstant" class="anchor"></a><code><span><span class="keyword">val</span> isNullPtrConstant : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the given expression is a null-pointer constant. As per 6.3.2.3 subsection 3</p></div></div><div class="odoc-spec"><div class="spec value" id="val-charConstToInt" class="anchored"><a href="#val-charConstToInt" class="anchor"></a><code><span><span class="keyword">val</span> charConstToInt : <span>char <span class="arrow">&#45;&gt;</span></span> <a href="#type-constant">constant</a></span></code></div><div class="spec-doc"><p>Given the character c in a (CChr c), sign-extend it to 32 bits. (This is the official way of interpreting character constants, according to ISO C 6.4.4.4.10, which says that character constants are chars cast to ints) Returns CInt(sign-extended c, IInt, None)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-constFold" class="anchored"><a href="#val-constFold" class="anchor"></a><code><span><span class="keyword">val</span> constFold : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Do constant folding on an expression. If the first argument is true then will also compute compiler-dependent expressions such as sizeof. See also <a href="#val-constFoldVisitor"><code>constFoldVisitor</code></a>, which will run constFold on all expressions in a given AST node.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-constFoldBinOp" class="anchored"><a href="#val-constFoldBinOp" class="anchor"></a><code><span><span class="keyword">val</span> constFoldBinOp : <span>bool <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Do constant folding on a binary operation. The bulk of the work done by <code>constFold</code> is done here. If the first argument is true then will also compute compiler-dependent expressions such as sizeof</p></div></div><div class="odoc-spec"><div class="spec value" id="val-increm" class="anchored"><a href="#val-increm" class="anchor"></a><code><span><span class="keyword">val</span> increm : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Increment an expression. Can be arithmetic or pointer type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-var" class="anchored"><a href="#val-var" class="anchor"></a><code><span><span class="keyword">val</span> var : <span><a href="#type-varinfo">varinfo</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lval">lval</a></span></code></div><div class="spec-doc"><p>Makes an lvalue out of a given variable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkAddrOf" class="anchored"><a href="#val-mkAddrOf" class="anchor"></a><code><span><span class="keyword">val</span> mkAddrOf : <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Make an AddrOf. Given an lvalue of type T will give back an expression of type ptr(T). It optimizes somewhat expressions like &quot;&amp; v&quot; and &quot;&amp; v<code>0</code>&quot;</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkAddrOrStartOf" class="anchored"><a href="#val-mkAddrOrStartOf" class="anchor"></a><code><span><span class="keyword">val</span> mkAddrOrStartOf : <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Like mkAddrOf except if the type of lval is an array then it uses StartOf. This is the right operation for getting a pointer to the start of the storage denoted by lval.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkMem" class="anchored"><a href="#val-mkMem" class="anchor"></a><code><span><span class="keyword">val</span> mkMem : <span>addr:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span>off:<a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lval">lval</a></span></code></div><div class="spec-doc"><p>Make a Mem, while optimizing AddrOf. The type of the addr must be TPtr(t) and the type of the resulting lval is t. Note that in CIL the implicit conversion between an array and the pointer to the first element does not apply. You must do the conversion yourself using StartOf</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkString" class="anchored"><a href="#val-mkString" class="anchor"></a><code><span><span class="keyword">val</span> mkString : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Make an expression that is a string constant (of pointer type)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCastT" class="anchored"><a href="#val-mkCastT" class="anchor"></a><code><span><span class="keyword">val</span> mkCastT : <span>e:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span>oldt:<a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span>newt:<a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Construct a cast when having the old type of the expression. If the new type is the same as the old type, then no cast is added.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCast" class="anchored"><a href="#val-mkCast" class="anchor"></a><code><span><span class="keyword">val</span> mkCast : <span>e:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span>newt:<a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Like <a href="#val-mkCastT"><code>mkCastT</code></a> but uses typeOf to get <code>oldt</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-stripCasts" class="anchored"><a href="#val-stripCasts" class="anchor"></a><code><span><span class="keyword">val</span> stripCasts : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Removes casts from this expression, but ignores casts within other expression constructs. So we delete the (A) and (B) casts from &quot;(A)(B)(x + (C)y)&quot;, but leave the (C) cast.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeOf" class="anchored"><a href="#val-typeOf" class="anchor"></a><code><span><span class="keyword">val</span> typeOf : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Compute the type of an expression</p></div></div><div class="odoc-spec"><div class="spec value" id="val-parseInt" class="anchored"><a href="#val-parseInt" class="anchor"></a><code><span><span class="keyword">val</span> parseInt : <span>string <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Convert a string representing a C integer literal to an expression. Handles the prefixes 0x and 0 and the suffixes L, U, UL, LL, ULL</p></div></div><p><b>Values for manipulating statements</b></p><div class="odoc-spec"><div class="spec value" id="val-mkStmt" class="anchored"><a href="#val-mkStmt" class="anchor"></a><code><span><span class="keyword">val</span> mkStmt : <span><a href="#type-stmtkind">stmtkind</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-stmt">stmt</a></span></code></div><div class="spec-doc"><p>Construct a statement, given its kind. Initialize the <code>sid</code> field to -1, and <code>labels</code>, <code>succs</code> and <code>preds</code> to the empty list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkBlock" class="anchored"><a href="#val-mkBlock" class="anchor"></a><code><span><span class="keyword">val</span> mkBlock : <span><span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-block">block</a></span></code></div><div class="spec-doc"><p>Construct a block with no attributes, given a list of statements</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkStmtOneInstr" class="anchored"><a href="#val-mkStmtOneInstr" class="anchor"></a><code><span><span class="keyword">val</span> mkStmtOneInstr : <span><a href="#type-instr">instr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-stmt">stmt</a></span></code></div><div class="spec-doc"><p>Construct a statement consisting of just one instruction</p></div></div><div class="odoc-spec"><div class="spec value" id="val-compactStmts" class="anchored"><a href="#val-compactStmts" class="anchor"></a><code><span><span class="keyword">val</span> compactStmts : <span><span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stmt">stmt</a> list</span></span></code></div><div class="spec-doc"><p>Try to compress statements so as to get maximal basic blocks. use this instead of List.@ because you get fewer basic blocks</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkEmptyStmt" class="anchored"><a href="#val-mkEmptyStmt" class="anchor"></a><code><span><span class="keyword">val</span> mkEmptyStmt : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="#type-stmt">stmt</a></span></code></div><div class="spec-doc"><p>Returns an empty statement (of kind <code>Instr</code>)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dummyInstr" class="anchored"><a href="#val-dummyInstr" class="anchor"></a><code><span><span class="keyword">val</span> dummyInstr : <a href="#type-instr">instr</a></span></code></div><div class="spec-doc"><p>A instr to serve as a placeholder</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dummyStmt" class="anchored"><a href="#val-dummyStmt" class="anchor"></a><code><span><span class="keyword">val</span> dummyStmt : <a href="#type-stmt">stmt</a></span></code></div><div class="spec-doc"><p>A statement consisting of just <code>dummyInstr</code></p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkWhile" class="anchored"><a href="#val-mkWhile" class="anchor"></a><code><span><span class="keyword">val</span> mkWhile : <span>guard:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span>body:<span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stmt">stmt</a> list</span></span></code></div><div class="spec-doc"><p>Make a while loop. Can contain Break or Continue</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkForIncr" class="anchored"><a href="#val-mkForIncr" class="anchor"></a><code><span><span class="keyword">val</span> mkForIncr : 
  <span>iter:<a href="#type-varinfo">varinfo</a> <span class="arrow">&#45;&gt;</span></span>
  <span>first:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span>stopat:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span>incr:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span>body:<span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-stmt">stmt</a> list</span></span></code></div><div class="spec-doc"><p>Make a for loop for(i=start; i&lt;past; i += incr) { ... }. The body can contain Break but not Continue. Can be used with i a pointer or an integer. Start and done must have the same type but incr must be an integer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkFor" class="anchored"><a href="#val-mkFor" class="anchor"></a><code><span><span class="keyword">val</span> mkFor : 
  <span>start:<span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>guard:<a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span>
  <span>next:<span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span>body:<span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-stmt">stmt</a> list</span></span></code></div><div class="spec-doc"><p>Make a for loop for(start; guard; next) { ... }. The body can contain Break but not Continue !!!</p></div></div><p><b>Values for manipulating attributes</b></p><div class="odoc-spec"><div class="spec type" id="type-attributeClass" class="anchored"><a href="#type-attributeClass" class="anchor"></a><code><span><span class="keyword">type</span> attributeClass</span><span> = </span></code><table><tr id="type-attributeClass.AttrName" class="anchored"><td class="def variant constructor"><a href="#type-attributeClass.AttrName" class="anchor"></a><code><span>| </span><span><span class="constructor">AttrName</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Attribute of a name.</p><span class="comment-delim">*)</span></td></tr><tr id="type-attributeClass.AttrFunType" class="anchored"><td class="def variant constructor"><a href="#type-attributeClass.AttrFunType" class="anchor"></a><code><span>| </span><span><span class="constructor">AttrFunType</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Attribute of a function type.</p><span class="comment-delim">*)</span></td></tr><tr id="type-attributeClass.AttrType" class="anchored"><td class="def variant constructor"><a href="#type-attributeClass.AttrType" class="anchor"></a><code><span>| </span><span><span class="constructor">AttrType</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Attribute of a type</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Various classes of attributes</p></div></div><div class="odoc-spec"><div class="spec value" id="val-attributeHash" class="anchored"><a href="#val-attributeHash" class="anchor"></a><code><span><span class="keyword">val</span> attributeHash : <span><span>( string, <a href="#type-attributeClass">attributeClass</a> )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span></span></code></div><div class="spec-doc"><p>This table contains the mapping of predefined attributes to classes. Extend this table with more attributes as you need. This table is used to determine how to associate attributes with names or types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partitionAttributes" class="anchored"><a href="#val-partitionAttributes" class="anchor"></a><code><span><span class="keyword">val</span> partitionAttributes : 
  <span>default:<a href="#type-attributeClass">attributeClass</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-attribute">attribute</a> list</span> * <span><a href="#type-attribute">attribute</a> list</span> * <span><a href="#type-attribute">attribute</a> list</span></span></code></div><div class="spec-doc"><p>Partition the attributes into classes:name attributes, function type, and type attributes</p></div></div><div class="odoc-spec"><div class="spec value" id="val-addAttribute" class="anchored"><a href="#val-addAttribute" class="anchor"></a><code><span><span class="keyword">val</span> addAttribute : <span><a href="#type-attribute">attribute</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Add an attribute. Maintains the attributes in sorted order of the second argument</p></div></div><div class="odoc-spec"><div class="spec value" id="val-addAttributes" class="anchored"><a href="#val-addAttributes" class="anchor"></a><code><span><span class="keyword">val</span> addAttributes : <span><span><a href="#type-attribute">attribute</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Add a list of attributes. Maintains the attributes in sorted order. The second argument must be sorted, but not necessarily the first</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dropAttribute" class="anchored"><a href="#val-dropAttribute" class="anchor"></a><code><span><span class="keyword">val</span> dropAttribute : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Remove all attributes with the given name. Maintains the attributes in sorted order.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dropAttributes" class="anchored"><a href="#val-dropAttributes" class="anchor"></a><code><span><span class="keyword">val</span> dropAttributes : <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Remove all attributes with names appearing in the string list. Maintains the attributes in sorted order</p></div></div><div class="odoc-spec"><div class="spec value" id="val-filterAttributes" class="anchored"><a href="#val-filterAttributes" class="anchor"></a><code><span><span class="keyword">val</span> filterAttributes : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attributes">attributes</a></span></code></div><div class="spec-doc"><p>Retains attributes with the given name</p></div></div><div class="odoc-spec"><div class="spec value" id="val-hasAttribute" class="anchored"><a href="#val-hasAttribute" class="anchor"></a><code><span><span class="keyword">val</span> hasAttribute : <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the named attribute appears in the attribute list. The list of attributes must be sorted.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeAttrs" class="anchored"><a href="#val-typeAttrs" class="anchor"></a><code><span><span class="keyword">val</span> typeAttrs : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attribute">attribute</a> list</span></span></code></div><div class="spec-doc"><p>Returns all the attributes contained in a type. This requires a traversal of the type structure, in case of composite, enumeration and named types</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeAttrsOuter" class="anchored"><a href="#val-typeAttrsOuter" class="anchor"></a><code><span><span class="keyword">val</span> typeAttrsOuter : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attribute">attribute</a> list</span></span></code></div><div class="spec-doc"><p><code>typeAttrs</code>, which doesn't add inner attributes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-setTypeAttrs" class="anchored"><a href="#val-setTypeAttrs" class="anchor"></a><code><span><span class="keyword">val</span> setTypeAttrs : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-typeAddAttributes" class="anchored"><a href="#val-typeAddAttributes" class="anchor"></a><code><span><span class="keyword">val</span> typeAddAttributes : <span><span><a href="#type-attribute">attribute</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Add some attributes to a type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-typeRemoveAttributes" class="anchored"><a href="#val-typeRemoveAttributes" class="anchor"></a><code><span><span class="keyword">val</span> typeRemoveAttributes : <span><span>string list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Remove all attributes with the given names from a type. Note that this does not remove attributes from typedef and tag definitions, just from their uses</p></div></div><div class="odoc-spec"><div class="spec value" id="val-partitionQualifierAttributes" class="anchored"><a href="#val-partitionQualifierAttributes" class="anchor"></a><code><span><span class="keyword">val</span> partitionQualifierAttributes : 
  <span><span><a href="#type-attribute">attribute</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="#type-attribute">attribute</a> list</span> * <span><a href="#type-attribute">attribute</a> list</span></span></code></div><div class="spec-doc"><p>Partition attributes into type qualifiers and non type qualifiers.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-removeOuterQualifierAttributes" class="anchored"><a href="#val-removeOuterQualifierAttributes" class="anchor"></a><code><span><span class="keyword">val</span> removeOuterQualifierAttributes : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Remove top-level type qualifiers from type.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-expToAttrParam" class="anchored"><a href="#val-expToAttrParam" class="anchor"></a><code><span><span class="keyword">val</span> expToAttrParam : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-attrparam">attrparam</a></span></code></div><div class="spec-doc"><p>Convert an expression into an attrparam, if possible. Otherwise raise NotAnAttrParam with the offending subexpression</p></div></div><div class="odoc-spec"><div class="spec exception" id="exception-NotAnAttrParam" class="anchored"><a href="#exception-NotAnAttrParam" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">NotAnAttrParam</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></div></div><p><b>The visitor</b></p><div class="odoc-spec"><div class="spec type" id="type-visitAction" class="anchored"><a href="#type-visitAction" class="anchor"></a><code><span><span class="keyword">type</span> <span>'a visitAction</span></span><span> = </span></code><table><tr id="type-visitAction.SkipChildren" class="anchored"><td class="def variant constructor"><a href="#type-visitAction.SkipChildren" class="anchor"></a><code><span>| </span><span><span class="constructor">SkipChildren</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Do not visit the children. Return the node as it is.</p><span class="comment-delim">*)</span></td></tr><tr id="type-visitAction.DoChildren" class="anchored"><td class="def variant constructor"><a href="#type-visitAction.DoChildren" class="anchor"></a><code><span>| </span><span><span class="constructor">DoChildren</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Continue with the children of this node. Rebuild the node on return if any of the children changes (use == test)</p><span class="comment-delim">*)</span></td></tr><tr id="type-visitAction.ChangeTo" class="anchored"><td class="def variant constructor"><a href="#type-visitAction.ChangeTo" class="anchor"></a><code><span>| </span><span><span class="constructor">ChangeTo</span> <span class="keyword">of</span> <span class="type-var">'a</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Replace the expression with the given one</p><span class="comment-delim">*)</span></td></tr><tr id="type-visitAction.ChangeDoChildrenPost" class="anchored"><td class="def variant constructor"><a href="#type-visitAction.ChangeDoChildrenPost" class="anchor"></a><code><span>| </span><span><span class="constructor">ChangeDoChildrenPost</span> <span class="keyword">of</span> <span class="type-var">'a</span> * <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>First consider that the entire exp is replaced by the first parameter. Then continue with the children. On return rebuild the node if any of the children has changed and then apply the function on the node</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Different visiting actions. 'a will be instantiated with <code>exp</code>, <code>instr</code>, etc.</p></div></div><div class="odoc-spec"><div class="spec class-type" id="class-type-cilVisitor" class="anchored"><a href="#class-type-cilVisitor" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">type</span>  </span><span><a href="class-type-cilVisitor/index.html">cilVisitor</a></span><span> = <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A visitor interface for traversing CIL trees. Create instantiations of this type by specializing the class <a href="class-nopCilVisitor/index.html"><code>nopCilVisitor</code></a>. Each of the specialized visiting functions can also call the <code>queueInstr</code> to specify that some instructions should be inserted before the current instruction or statement. Use syntax like <code>self#queueInstr</code> to call a method associated with the current object.</p></div></div><div class="odoc-spec"><div class="spec class" id="class-nopCilVisitor" class="anchored"><a href="#class-nopCilVisitor" class="anchor"></a><code><span><span class="keyword">class</span>  </span><span><a href="class-nopCilVisitor/index.html">nopCilVisitor</a></span><span> : <a href="class-type-cilVisitor/index.html">cilVisitor</a></span></code></div><div class="spec-doc"><p>Default Visitor. Traverses the CIL tree without modifying anything</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilFile" class="anchored"><a href="#val-visitCilFile" class="anchor"></a><code><span><span class="keyword">val</span> visitCilFile : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Visit a file. This will will re-cons all globals TWICE (so that it is tail-recursive). Use <a href="#val-visitCilFileSameGlobals"><code>visitCilFileSameGlobals</code></a> if your visitor will not change the list of globals.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilFileSameGlobals" class="anchored"><a href="#val-visitCilFileSameGlobals" class="anchor"></a><code><span><span class="keyword">val</span> visitCilFileSameGlobals : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>A visitor for the whole file that does not change the globals (but maybe changes things inside the globals). Use this function instead of <a href="#val-visitCilFile"><code>visitCilFile</code></a> whenever appropriate because it is more efficient for long files.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilGlobal" class="anchored"><a href="#val-visitCilGlobal" class="anchor"></a><code><span><span class="keyword">val</span> visitCilGlobal : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> list</span></span></code></div><div class="spec-doc"><p>Visit a global</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilFunction" class="anchored"><a href="#val-visitCilFunction" class="anchor"></a><code><span><span class="keyword">val</span> visitCilFunction : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fundec">fundec</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-fundec">fundec</a></span></code></div><div class="spec-doc"><p>Visit a function definition</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilExpr" class="anchored"><a href="#val-visitCilExpr" class="anchor"></a><code><span><span class="keyword">val</span> visitCilExpr : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilLval" class="anchored"><a href="#val-visitCilLval" class="anchor"></a><code><span><span class="keyword">val</span> visitCilLval : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-lval">lval</a></span></code></div><div class="spec-doc"><p>Visit an lvalue</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilOffset" class="anchored"><a href="#val-visitCilOffset" class="anchor"></a><code><span><span class="keyword">val</span> visitCilOffset : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-offset">offset</a></span></code></div><div class="spec-doc"><p>Visit an lvalue or recursive offset</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilInitOffset" class="anchored"><a href="#val-visitCilInitOffset" class="anchor"></a><code><span><span class="keyword">val</span> visitCilInitOffset : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-offset">offset</a></span></code></div><div class="spec-doc"><p>Visit an initializer offset</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilInstr" class="anchored"><a href="#val-visitCilInstr" class="anchor"></a><code><span><span class="keyword">val</span> visitCilInstr : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-instr">instr</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-instr">instr</a> list</span></span></code></div><div class="spec-doc"><p>Visit an instruction</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilStmt" class="anchored"><a href="#val-visitCilStmt" class="anchor"></a><code><span><span class="keyword">val</span> visitCilStmt : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stmt">stmt</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-stmt">stmt</a></span></code></div><div class="spec-doc"><p>Visit a statement</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilBlock" class="anchored"><a href="#val-visitCilBlock" class="anchor"></a><code><span><span class="keyword">val</span> visitCilBlock : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-block">block</a></span></code></div><div class="spec-doc"><p>Visit a block</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilType" class="anchored"><a href="#val-visitCilType" class="anchor"></a><code><span><span class="keyword">val</span> visitCilType : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Visit a type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilVarDecl" class="anchored"><a href="#val-visitCilVarDecl" class="anchor"></a><code><span><span class="keyword">val</span> visitCilVarDecl : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-varinfo">varinfo</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-varinfo">varinfo</a></span></code></div><div class="spec-doc"><p>Visit a variable declaration</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilInit" class="anchored"><a href="#val-visitCilInit" class="anchor"></a><code><span><span class="keyword">val</span> visitCilInit : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-varinfo">varinfo</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-init">init</a></span></code></div><div class="spec-doc"><p>Visit an initializer, pass also the variable to which this belongs and the offset.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-visitCilAttributes" class="anchored"><a href="#val-visitCilAttributes" class="anchor"></a><code><span><span class="keyword">val</span> visitCilAttributes : <span><a href="class-type-cilVisitor/index.html">cilVisitor</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-attribute">attribute</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attribute">attribute</a> list</span></span></code></div><div class="spec-doc"><p>Visit a list of attributes</p></div></div><p><b>Utility functions</b></p><div class="odoc-spec"><div class="spec value" id="val-msvcMode" class="anchored"><a href="#val-msvcMode" class="anchor"></a><code><span><span class="keyword">val</span> msvcMode : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether the pretty printer should print output for the MS VC compiler. Default is GCC. After you set this function you should call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-makeStaticGlobal" class="anchored"><a href="#val-makeStaticGlobal" class="anchor"></a><code><span><span class="keyword">val</span> makeStaticGlobal : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether to convert local static variables into global static variables</p></div></div><div class="odoc-spec"><div class="spec value" id="val-useLogicalOperators" class="anchored"><a href="#val-useLogicalOperators" class="anchor"></a><code><span><span class="keyword">val</span> useLogicalOperators : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether to use the logical operands LAnd and LOr. By default, do not use them because they are unlike other expressions and do not evaluate both of their operands</p></div></div><div class="odoc-spec"><div class="spec value" id="val-useComputedGoto" class="anchored"><a href="#val-useComputedGoto" class="anchor"></a><code><span><span class="keyword">val</span> useComputedGoto : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether to use GCC's computed gotos. By default, do not use them and replace them by a switch.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-useCaseRange" class="anchored"><a href="#val-useCaseRange" class="anchor"></a><code><span><span class="keyword">val</span> useCaseRange : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether to expand ranges of values in case statements. By default, expand them and do not use the CaseRange constructor.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-caseRangeFold" class="anchored"><a href="#val-caseRangeFold" class="anchor"></a><code><span><span class="keyword">val</span> caseRangeFold : <span><span><a href="#type-label">label</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-label">label</a> list</span></span></code></div><div class="spec-doc"><p>Fold every <a href="#type-label.CaseRange"><code>CaseRange</code></a> in a list of labels into the corresponding list of <a href="#type-label.Case"><code>Case</code></a> labels. Raises <a href="Errormsg/index.html#exception-Error"><code>Errormsg.Error</code></a> if one of the ranges cannot be constant folded.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-oldstyleExternInline" class="anchored"><a href="#val-oldstyleExternInline" class="anchor"></a><code><span><span class="keyword">val</span> oldstyleExternInline : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Set this to true to get old-style handling of gcc's extern inline C extension: old-style: the extern inline definition is used until the actual definition is seen (as long as optimization is enabled) new-style: the extern inline definition is used only if there is no actual definition (as long as optimization is enabled) Note that CIL assumes that optimization is always enabled ;-)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-constFoldVisitor" class="anchored"><a href="#val-constFoldVisitor" class="anchor"></a><code><span><span class="keyword">val</span> constFoldVisitor : <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="class-type-cilVisitor/index.html">cilVisitor</a></span></code></div><div class="spec-doc"><p>A visitor that does constant folding. Pass as argument whether you want machine specific simplifications to be done, or not.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-lineDirectiveStyle" class="anchored"><a href="#type-lineDirectiveStyle" class="anchor"></a><code><span><span class="keyword">type</span> lineDirectiveStyle</span><span> = </span></code><table><tr id="type-lineDirectiveStyle.LineComment" class="anchored"><td class="def variant constructor"><a href="#type-lineDirectiveStyle.LineComment" class="anchor"></a><code><span>| </span><span><span class="constructor">LineComment</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Before every element, print the line number in comments. This is ignored by processing tools (thus errors are reproted in the CIL output), but useful for visual inspection</p><span class="comment-delim">*)</span></td></tr><tr id="type-lineDirectiveStyle.LineCommentSparse" class="anchored"><td class="def variant constructor"><a href="#type-lineDirectiveStyle.LineCommentSparse" class="anchor"></a><code><span>| </span><span><span class="constructor">LineCommentSparse</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Like LineComment but only print a line directive for a new source line</p><span class="comment-delim">*)</span></td></tr><tr id="type-lineDirectiveStyle.LinePreprocessorInput" class="anchored"><td class="def variant constructor"><a href="#type-lineDirectiveStyle.LinePreprocessorInput" class="anchor"></a><code><span>| </span><span><span class="constructor">LinePreprocessorInput</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Use # nnn directives (in gcc mode)</p><span class="comment-delim">*)</span></td></tr><tr id="type-lineDirectiveStyle.LinePreprocessorOutput" class="anchored"><td class="def variant constructor"><a href="#type-lineDirectiveStyle.LinePreprocessorOutput" class="anchor"></a><code><span>| </span><span><span class="constructor">LinePreprocessorOutput</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>Use #line directives</p><span class="comment-delim">*)</span></td></tr></table></div><div class="spec-doc"><p>Styles of printing line directives</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lineDirectiveStyle" class="anchored"><a href="#val-lineDirectiveStyle" class="anchor"></a><code><span><span class="keyword">val</span> lineDirectiveStyle : <span><span><a href="#type-lineDirectiveStyle">lineDirectiveStyle</a> option</span> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>How to print line directives</p></div></div><div class="odoc-spec"><div class="spec value" id="val-print_CIL_Input" class="anchored"><a href="#val-print_CIL_Input" class="anchor"></a><code><span><span class="keyword">val</span> print_CIL_Input : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether we print something that will only be used as input to our own parser. In that case we are a bit more liberal in what we print</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printCilAsIs" class="anchored"><a href="#val-printCilAsIs" class="anchor"></a><code><span><span class="keyword">val</span> printCilAsIs : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether to print the CIL as they are, without trying to be smart and print nicer code. Normally this is false, in which case the pretty printer will turn the while(1) loops of CIL into nicer loops, will not print empty &quot;else&quot; blocks, etc. There is one case howewer in which if you turn this on you will get code that does not compile: if you use varargs the __builtin_va_arg function will be printed in its internal form.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-lineLength" class="anchored"><a href="#val-lineLength" class="anchor"></a><code><span><span class="keyword">val</span> lineLength : <span>int <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>The length used when wrapping output lines. Setting this variable to a large integer will prevent wrapping and make #line directives more accurate.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-forgcc" class="anchored"><a href="#val-forgcc" class="anchor"></a><code><span><span class="keyword">val</span> forgcc : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>Return the string 's' if we're printing output for gcc, suppres it if we're printing for CIL to parse back in. the purpose is to hide things from gcc that it complains about, but still be able to do lossless transformations when CIL is the consumer</p></div></div><p><b>Debugging support</b></p><div class="odoc-spec"><div class="spec value" id="val-currentLoc" class="anchored"><a href="#val-currentLoc" class="anchor"></a><code><span><span class="keyword">val</span> currentLoc : <span><a href="#type-location">location</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>A reference to the current location. If you are careful to set this to the current location then you can use some built-in logging functions that will print the location.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-currentExpLoc" class="anchored"><a href="#val-currentExpLoc" class="anchor"></a><code><span><span class="keyword">val</span> currentExpLoc : <span><a href="#type-location">location</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>A reference to the current expression location</p></div></div><div class="odoc-spec"><div class="spec value" id="val-currentGlobal" class="anchored"><a href="#val-currentGlobal" class="anchor"></a><code><span><span class="keyword">val</span> currentGlobal : <span><a href="#type-global">global</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>A reference to the current global being visited</p></div></div><p>CIL has a fairly easy to use mechanism for printing error messages. This mechanism is built on top of the pretty-printer mechanism (see <a href="Pretty/index.html#type-doc"><code>Pretty.doc</code></a>) and the error-message modules (see <a href="Errormsg/index.html#val-error"><code>Errormsg.error</code></a>).</p><p>Here is a typical example for printing a log message:</p><pre><code>ignore (Errormsg.log &quot;Expression %a is not positive (at %s:%i)\n&quot;
                        d_exp e loc.file loc.line)</code></pre><p>and here is an example of how you print a fatal error message that stop the execution:</p><pre><code>Errormsg.s (Errormsg.bug &quot;Why am I here?&quot;)</code></pre><p>Notice that you can use C format strings with some extension. The most useful extension is &quot;%a&quot; that means to consumer the next two argument from the argument list and to apply the first to <code>unit</code> and then to the second and to print the resulting <a href="Pretty/index.html#type-doc"><code>Pretty.doc</code></a>. For each major type in CIL there is a corresponding function that pretty-prints an element of that type:</p><div class="odoc-spec"><div class="spec value" id="val-d_loc" class="anchored"><a href="#val-d_loc" class="anchor"></a><code><span><span class="keyword">val</span> d_loc : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a location</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_thisloc" class="anchored"><a href="#val-d_thisloc" class="anchor"></a><code><span><span class="keyword">val</span> d_thisloc : <span>unit <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print the <a href="#val-currentLoc"><code>currentLoc</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_ikind" class="anchored"><a href="#val-d_ikind" class="anchor"></a><code><span><span class="keyword">val</span> d_ikind : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an integer of a given kind</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_fkind" class="anchored"><a href="#val-d_fkind" class="anchor"></a><code><span><span class="keyword">val</span> d_fkind : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-fkind">fkind</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a floating-point kind</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_storage" class="anchored"><a href="#val-d_storage" class="anchor"></a><code><span><span class="keyword">val</span> d_storage : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-storage">storage</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print storage-class information</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_const" class="anchored"><a href="#val-d_const" class="anchor"></a><code><span><span class="keyword">val</span> d_const : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-constant">constant</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a constant</p></div></div><div class="odoc-spec"><div class="spec value" id="val-derefStarLevel" class="anchored"><a href="#val-derefStarLevel" class="anchor"></a><code><span><span class="keyword">val</span> derefStarLevel : int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-indexLevel" class="anchored"><a href="#val-indexLevel" class="anchor"></a><code><span><span class="keyword">val</span> indexLevel : int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-arrowLevel" class="anchored"><a href="#val-arrowLevel" class="anchor"></a><code><span><span class="keyword">val</span> arrowLevel : int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-addrOfLevel" class="anchored"><a href="#val-addrOfLevel" class="anchor"></a><code><span><span class="keyword">val</span> addrOfLevel : int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-additiveLevel" class="anchored"><a href="#val-additiveLevel" class="anchor"></a><code><span><span class="keyword">val</span> additiveLevel : int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-comparativeLevel" class="anchored"><a href="#val-comparativeLevel" class="anchor"></a><code><span><span class="keyword">val</span> comparativeLevel : int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-bitwiseLevel" class="anchored"><a href="#val-bitwiseLevel" class="anchor"></a><code><span><span class="keyword">val</span> bitwiseLevel : int</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-getParenthLevel" class="anchored"><a href="#val-getParenthLevel" class="anchor"></a><code><span><span class="keyword">val</span> getParenthLevel : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Parentheses level. An expression &quot;a op b&quot; is printed parenthesized if its parentheses level is &gt;= that that of its context. Identifiers have the lowest level and weakly binding operators (e.g. |) have the largest level. The correctness criterion is that a smaller level MUST correspond to a stronger precedence!</p></div></div><div class="odoc-spec"><div class="spec class-type" id="class-type-cilPrinter" class="anchored"><a href="#class-type-cilPrinter" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">type</span>  </span><span><a href="class-type-cilPrinter/index.html">cilPrinter</a></span><span> = <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A printer interface for CIL trees. Create instantiations of this type by specializing the class <a href="class-defaultCilPrinterClass/index.html"><code>defaultCilPrinterClass</code></a>.</p></div></div><div class="odoc-spec"><div class="spec class" id="class-defaultCilPrinterClass" class="anchored"><a href="#class-defaultCilPrinterClass" class="anchor"></a><code><span><span class="keyword">class</span>  </span><span><a href="class-defaultCilPrinterClass/index.html">defaultCilPrinterClass</a></span><span> : <a href="class-type-cilPrinter/index.html">cilPrinter</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-defaultCilPrinter" class="anchored"><a href="#val-defaultCilPrinter" class="anchor"></a><code><span><span class="keyword">val</span> defaultCilPrinter : <a href="class-type-cilPrinter/index.html">cilPrinter</a></span></code></div></div><div class="odoc-spec"><div class="spec class" id="class-plainCilPrinterClass" class="anchored"><a href="#class-plainCilPrinterClass" class="anchor"></a><code><span><span class="keyword">class</span>  </span><span><a href="class-plainCilPrinterClass/index.html">plainCilPrinterClass</a></span><span> : <a href="class-type-cilPrinter/index.html">cilPrinter</a></span></code></div><div class="spec-doc"><p>These are pretty-printers that will show you more details on the internal CIL representation, without trying hard to make it look like C</p></div></div><div class="odoc-spec"><div class="spec value" id="val-plainCilPrinter" class="anchored"><a href="#val-plainCilPrinter" class="anchor"></a><code><span><span class="keyword">val</span> plainCilPrinter : <a href="class-type-cilPrinter/index.html">cilPrinter</a></span></code></div></div><div class="odoc-spec"><div class="spec class-type" id="class-type-descriptiveCilPrinter" class="anchored"><a href="#class-type-descriptiveCilPrinter" class="anchor"></a><code><span><span class="keyword">class</span> <span class="keyword">type</span>  </span><span><a href="class-type-descriptiveCilPrinter/index.html">descriptiveCilPrinter</a></span><span> = <span class="keyword">object</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec class" id="class-descriptiveCilPrinterClass" class="anchored"><a href="#class-descriptiveCilPrinterClass" class="anchor"></a><code><span><span class="keyword">class</span>  </span><span><a href="class-descriptiveCilPrinterClass/index.html">descriptiveCilPrinterClass</a></span><span> : <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="class-type-descriptiveCilPrinter/index.html">descriptiveCilPrinter</a></span></code></div><div class="spec-doc"><p>Like defaultCilPrinterClass, but instead of temporary variable names it prints the description that was provided when the temp was created. This is usually better for messages that are printed for end users, although you may want the temporary names for debugging.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-descriptiveCilPrinter" class="anchored"><a href="#val-descriptiveCilPrinter" class="anchor"></a><code><span><span class="keyword">val</span> descriptiveCilPrinter : <a href="class-type-descriptiveCilPrinter/index.html">descriptiveCilPrinter</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-printerForMaincil" class="anchored"><a href="#val-printerForMaincil" class="anchor"></a><code><span><span class="keyword">val</span> printerForMaincil : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>zra: This is the pretty printer that Maincil will use. by default it is set to defaultCilPrinter</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printType" class="anchored"><a href="#val-printType" class="anchor"></a><code><span><span class="keyword">val</span> printType : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print a type given a pretty printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printExp" class="anchored"><a href="#val-printExp" class="anchor"></a><code><span><span class="keyword">val</span> printExp : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print an expression given a pretty printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printLval" class="anchored"><a href="#val-printLval" class="anchor"></a><code><span><span class="keyword">val</span> printLval : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print an lvalue given a pretty printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printGlobal" class="anchored"><a href="#val-printGlobal" class="anchor"></a><code><span><span class="keyword">val</span> printGlobal : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print a global given a pretty printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printAttr" class="anchored"><a href="#val-printAttr" class="anchor"></a><code><span><span class="keyword">val</span> printAttr : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attribute">attribute</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print an attribute given a pretty printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printAttrs" class="anchored"><a href="#val-printAttrs" class="anchor"></a><code><span><span class="keyword">val</span> printAttrs : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print a set of attributes given a pretty printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printInstr" class="anchored"><a href="#val-printInstr" class="anchor"></a><code><span><span class="keyword">val</span> printInstr : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-instr">instr</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print an instruction given a pretty printer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printStmt" class="anchored"><a href="#val-printStmt" class="anchor"></a><code><span><span class="keyword">val</span> printStmt : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stmt">stmt</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print a statement given a pretty printer. This can take very long (or even overflow the stack) for huge statements. Use <a href="#val-dumpStmt"><code>dumpStmt</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printBlock" class="anchored"><a href="#val-printBlock" class="anchor"></a><code><span><span class="keyword">val</span> printBlock : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print a block given a pretty printer. This can take very long (or even overflow the stack) for huge block. Use <a href="#val-dumpBlock"><code>dumpBlock</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dumpStmt" class="anchored"><a href="#val-dumpStmt" class="anchor"></a><code><span><span class="keyword">val</span> dumpStmt : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stmt">stmt</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Dump a statement to a file using a given indentation. Use this instead of <a href="#val-printStmt"><code>printStmt</code></a> whenever possible.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dumpBlock" class="anchored"><a href="#val-dumpBlock" class="anchor"></a><code><span><span class="keyword">val</span> dumpBlock : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Dump a block to a file using a given indentation. Use this instead of <a href="#val-printBlock"><code>printBlock</code></a> whenever possible.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-printInit" class="anchored"><a href="#val-printInit" class="anchor"></a><code><span><span class="keyword">val</span> printInit : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Print an initializer given a pretty printer. This can take very long (or even overflow the stack) for huge initializers. Use <a href="#val-dumpInit"><code>dumpInit</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dumpInit" class="anchored"><a href="#val-dumpInit" class="anchor"></a><code><span><span class="keyword">val</span> dumpInit : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span>int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Dump an initializer to a file using a given indentation. Use this instead of <a href="#val-printInit"><code>printInit</code></a> whenever possible.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_type" class="anchored"><a href="#val-d_type" class="anchor"></a><code><span><span class="keyword">val</span> d_type : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a type using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_exp" class="anchored"><a href="#val-d_exp" class="anchor"></a><code><span><span class="keyword">val</span> d_exp : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an expression using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_lval" class="anchored"><a href="#val-d_lval" class="anchor"></a><code><span><span class="keyword">val</span> d_lval : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an lvalue using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_offset" class="anchored"><a href="#val-d_offset" class="anchor"></a><code><span><span class="keyword">val</span> d_offset : <span><a href="Pretty/index.html#type-doc">Pretty.doc</a> <span class="arrow">&#45;&gt;</span></span> <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an offset using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a>, given the pretty printing for the base.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_init" class="anchored"><a href="#val-d_init" class="anchor"></a><code><span><span class="keyword">val</span> d_init : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an initializer using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a>. This can be extremely slow (or even overflow the stack) for huge initializers. Use <a href="#val-dumpInit"><code>dumpInit</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_binop" class="anchored"><a href="#val-d_binop" class="anchor"></a><code><span><span class="keyword">val</span> d_binop : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-binop">binop</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a binary operator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_unop" class="anchored"><a href="#val-d_unop" class="anchor"></a><code><span><span class="keyword">val</span> d_unop : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-unop">unop</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a unary operator</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_attr" class="anchored"><a href="#val-d_attr" class="anchor"></a><code><span><span class="keyword">val</span> d_attr : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attribute">attribute</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an attribute using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_attrparam" class="anchored"><a href="#val-d_attrparam" class="anchor"></a><code><span><span class="keyword">val</span> d_attrparam : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attrparam">attrparam</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an argument of an attribute using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_attrlist" class="anchored"><a href="#val-d_attrlist" class="anchor"></a><code><span><span class="keyword">val</span> d_attrlist : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a list of attributes using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_instr" class="anchored"><a href="#val-d_instr" class="anchor"></a><code><span><span class="keyword">val</span> d_instr : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-instr">instr</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an instruction using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_label" class="anchored"><a href="#val-d_label" class="anchor"></a><code><span><span class="keyword">val</span> d_label : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-label">label</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a label using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_stmt" class="anchored"><a href="#val-d_stmt" class="anchor"></a><code><span><span class="keyword">val</span> d_stmt : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stmt">stmt</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a statement using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a>. This can be extremely slow (or even overflow the stack) for huge statements. Use <a href="#val-dumpStmt"><code>dumpStmt</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_block" class="anchored"><a href="#val-d_block" class="anchor"></a><code><span><span class="keyword">val</span> d_block : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-block">block</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a block using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a>. This can be extremely slow (or even overflow the stack) for huge blocks. Use <a href="#val-dumpBlock"><code>dumpBlock</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_global" class="anchored"><a href="#val-d_global" class="anchor"></a><code><span><span class="keyword">val</span> d_global : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print the internal representation of a global using <a href="#val-defaultCilPrinter"><code>defaultCilPrinter</code></a>. This can be extremely slow (or even overflow the stack) for huge globals (such as arrays with lots of initializers). Use <a href="#val-dumpGlobal"><code>dumpGlobal</code></a> instead.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_exp" class="anchored"><a href="#val-dn_exp" class="anchor"></a><code><span><span class="keyword">val</span> dn_exp : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Versions of the above pretty printers, that don't print #line directives</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_lval" class="anchored"><a href="#val-dn_lval" class="anchor"></a><code><span><span class="keyword">val</span> dn_lval : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_init" class="anchored"><a href="#val-dn_init" class="anchor"></a><code><span><span class="keyword">val</span> dn_init : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_type" class="anchored"><a href="#val-dn_type" class="anchor"></a><code><span><span class="keyword">val</span> dn_type : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_global" class="anchored"><a href="#val-dn_global" class="anchor"></a><code><span><span class="keyword">val</span> dn_global : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_attrlist" class="anchored"><a href="#val-dn_attrlist" class="anchor"></a><code><span><span class="keyword">val</span> dn_attrlist : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attributes">attributes</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_attr" class="anchored"><a href="#val-dn_attr" class="anchor"></a><code><span><span class="keyword">val</span> dn_attr : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attribute">attribute</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_attrparam" class="anchored"><a href="#val-dn_attrparam" class="anchor"></a><code><span><span class="keyword">val</span> dn_attrparam : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-attrparam">attrparam</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_stmt" class="anchored"><a href="#val-dn_stmt" class="anchor"></a><code><span><span class="keyword">val</span> dn_stmt : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-stmt">stmt</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-dn_instr" class="anchored"><a href="#val-dn_instr" class="anchor"></a><code><span><span class="keyword">val</span> dn_instr : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-instr">instr</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-d_shortglobal" class="anchored"><a href="#val-d_shortglobal" class="anchor"></a><code><span><span class="keyword">val</span> d_shortglobal : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print a short description of the global. This is useful for error messages</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dumpGlobal" class="anchored"><a href="#val-dumpGlobal" class="anchor"></a><code><span><span class="keyword">val</span> dumpGlobal : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print a global. Here you give the channel where the printout should be sent.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dumpFile" class="anchored"><a href="#val-dumpFile" class="anchor"></a><code><span><span class="keyword">val</span> dumpFile : <span><a href="class-type-cilPrinter/index.html">cilPrinter</a> <span class="arrow">&#45;&gt;</span></span> <span><span class="xref-unresolved">Stdlib</span>.out_channel <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Pretty-print an entire file. Here you give the channel where the printout should be sent.</p></div></div><p>the following error message producing functions also print a location in the code. use <a href="Errormsg/index.html#val-bug"><code>Errormsg.bug</code></a> and <a href="Errormsg/index.html#val-unimp"><code>Errormsg.unimp</code></a> if you do not want that</p><div class="odoc-spec"><div class="spec value" id="val-bug" class="anchored"><a href="#val-bug" class="anchor"></a><code><span><span class="keyword">val</span> bug : <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="Errormsg/index.html#val-bug"><code>Errormsg.bug</code></a> except that <a href="#val-currentLoc"><code>currentLoc</code></a> is also printed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unimp" class="anchored"><a href="#val-unimp" class="anchor"></a><code><span><span class="keyword">val</span> unimp : <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="Errormsg/index.html#val-unimp"><code>Errormsg.unimp</code></a> except that <a href="#val-currentLoc"><code>currentLoc</code></a>is also printed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-error" class="anchored"><a href="#val-error" class="anchor"></a><code><span><span class="keyword">val</span> error : <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="Errormsg/index.html#val-error"><code>Errormsg.error</code></a> except that <a href="#val-currentLoc"><code>currentLoc</code></a> is also printed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-errorLoc" class="anchored"><a href="#val-errorLoc" class="anchor"></a><code><span><span class="keyword">val</span> errorLoc : <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="#val-error"><code>error</code></a> except that it explicitly takes a location argument, instead of using the <a href="#val-currentLoc"><code>currentLoc</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-warn" class="anchored"><a href="#val-warn" class="anchor"></a><code><span><span class="keyword">val</span> warn : <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="Errormsg/index.html#val-warn"><code>Errormsg.warn</code></a> except that <a href="#val-currentLoc"><code>currentLoc</code></a> is also printed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-warnOpt" class="anchored"><a href="#val-warnOpt" class="anchor"></a><code><span><span class="keyword">val</span> warnOpt : <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="Errormsg/index.html#val-warnOpt"><code>Errormsg.warnOpt</code></a> except that <a href="#val-currentLoc"><code>currentLoc</code></a> is also printed. This warning is printed only of <a href="Errormsg/index.html#val-warnFlag"><code>Errormsg.warnFlag</code></a> is set.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-warnContext" class="anchored"><a href="#val-warnContext" class="anchor"></a><code><span><span class="keyword">val</span> warnContext : <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="Errormsg/index.html#val-warn"><code>Errormsg.warn</code></a> except that <a href="#val-currentLoc"><code>currentLoc</code></a> and context is also printed</p></div></div><div class="odoc-spec"><div class="spec value" id="val-warnContextOpt" class="anchored"><a href="#val-warnContextOpt" class="anchor"></a><code><span><span class="keyword">val</span> warnContextOpt : <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="Errormsg/index.html#val-warn"><code>Errormsg.warn</code></a> except that <a href="#val-currentLoc"><code>currentLoc</code></a> and context is also printed. This warning is printed only of <a href="Errormsg/index.html#val-warnFlag"><code>Errormsg.warnFlag</code></a> is set.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-warnLoc" class="anchored"><a href="#val-warnLoc" class="anchor"></a><code><span><span class="keyword">val</span> warnLoc : <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <span><span><span>( <span class="type-var">'a</span>, unit, <a href="Pretty/index.html#type-doc">Pretty.doc</a> )</span> <span class="xref-unresolved">Stdlib</span>.format</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span></span></code></div><div class="spec-doc"><p>Like <a href="#val-warn"><code>warn</code></a> except that it explicitly takes a location argument, instead of using the <a href="#val-currentLoc"><code>currentLoc</code></a></p></div></div><p>Sometimes you do not want to see the syntactic sugar that the above pretty-printing functions add. In that case you can use the following pretty-printing functions. But note that the output of these functions is not valid C</p><div class="odoc-spec"><div class="spec value" id="val-d_plainexp" class="anchored"><a href="#val-d_plainexp" class="anchor"></a><code><span><span class="keyword">val</span> d_plainexp : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print the internal representation of an expression</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_plaininit" class="anchored"><a href="#val-d_plaininit" class="anchor"></a><code><span><span class="keyword">val</span> d_plaininit : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-init">init</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print the internal representation of an integer</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_plainlval" class="anchored"><a href="#val-d_plainlval" class="anchor"></a><code><span><span class="keyword">val</span> d_plainlval : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print the internal representation of an lvalue</p></div></div><p>Pretty-print the internal representation of an lvalue offset val d_plainoffset: unit -&gt; offset -&gt; Pretty.doc</p><div class="odoc-spec"><div class="spec value" id="val-d_plaintype" class="anchored"><a href="#val-d_plaintype" class="anchor"></a><code><span><span class="keyword">val</span> d_plaintype : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print the internal representation of a type</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dd_exp" class="anchored"><a href="#val-dd_exp" class="anchor"></a><code><span><span class="keyword">val</span> dd_exp : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an expression while printing descriptions rather than names of temporaries.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dd_lval" class="anchored"><a href="#val-dd_lval" class="anchor"></a><code><span><span class="keyword">val</span> dd_lval : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-lval">lval</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-print an lvalue on the left side of an assignment. If there is an offset or memory dereference, temporaries will be replaced by descriptions as in dd_exp. If the lval is a temp var, that var will not be replaced by a description; use &quot;dd_exp () (Lval lv)&quot; if that's what you want.</p></div></div><p><b>ALPHA conversion</b> has been moved to the Alpha module.</p><div class="odoc-spec"><div class="spec value" id="val-uniqueVarNames" class="anchored"><a href="#val-uniqueVarNames" class="anchor"></a><code><span><span class="keyword">val</span> uniqueVarNames : <span><a href="#type-file">file</a> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Assign unique names to local variables. This might be necessary after you transformed the code and added or renamed some new variables. Names are not used by CIL internally, but once you print the file out the compiler downstream might be confused. You might have added a new global that happens to have the same name as a local in some function. Rename the local to ensure that there would never be confusion. Or, viceversa, you might have added a local with a name that conflicts with a global</p></div></div><p><b>Optimization Passes</b></p><div class="odoc-spec"><div class="spec value" id="val-peepHole2" class="anchored"><a href="#val-peepHole2" class="anchor"></a><code><span><span class="keyword">val</span> peepHole2 : <span><span>( <span><span>(<a href="#type-instr">instr</a> * <a href="#type-instr">instr</a>)</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-instr">instr</a> list</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>A peephole optimizer that processes two adjacent instructions and possibly replaces them both. If some replacement happens, then the new instructions are themselves subject to optimization</p></div></div><div class="odoc-spec"><div class="spec value" id="val-peepHole1" class="anchored"><a href="#val-peepHole1" class="anchor"></a><code><span><span class="keyword">val</span> peepHole1 : <span><span>( <span><a href="#type-instr">instr</a> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-instr">instr</a> list</span> option</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><a href="#type-stmt">stmt</a> list</span> <span class="arrow">&#45;&gt;</span></span> unit</span></code></div><div class="spec-doc"><p>Similar to <code>peepHole2</code> except that the optimization window consists of one instruction, not two</p></div></div><p><b>Machine dependency</b></p><div class="odoc-spec"><div class="spec exception" id="exception-SizeOfError" class="anchored"><a href="#exception-SizeOfError" class="anchor"></a><code><span><span class="keyword">exception</span> </span><span><span class="exception">SizeOfError</span> <span class="keyword">of</span> string * <a href="#type-typ">typ</a></span></code></div><div class="spec-doc"><p>Raised when one of the bitsSizeOf functions cannot compute the size of a type. This can happen because the type contains array-length expressions that we don't know how to compute or because it is a type whose size is not defined (e.g. TFun or an undefined compinfo). The string is an explanation of the error</p></div></div><div class="odoc-spec"><div class="spec value" id="val-unsignedVersionOf" class="anchored"><a href="#val-unsignedVersionOf" class="anchor"></a><code><span><span class="keyword">val</span> unsignedVersionOf : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ikind">ikind</a></span></code></div><div class="spec-doc"><p>Give the unsigned kind corresponding to any integer kind</p></div></div><div class="odoc-spec"><div class="spec value" id="val-signedVersionOf" class="anchored"><a href="#val-signedVersionOf" class="anchor"></a><code><span><span class="keyword">val</span> signedVersionOf : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ikind">ikind</a></span></code></div><div class="spec-doc"><p>Give the signed kind corresponding to any integer kind</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intRank" class="anchored"><a href="#val-intRank" class="anchor"></a><code><span><span class="keyword">val</span> intRank : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>Return the integer conversion rank of an integer kind</p></div></div><div class="odoc-spec"><div class="spec value" id="val-commonIntKind" class="anchored"><a href="#val-commonIntKind" class="anchor"></a><code><span><span class="keyword">val</span> commonIntKind : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-ikind">ikind</a></span></code></div><div class="spec-doc"><p>Return the common integer kind of the two integer arguments, as defined in ISO C 6.3.1.8 (&quot;Usual arithmetic conversions&quot;)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intKindForSize" class="anchored"><a href="#val-intKindForSize" class="anchor"></a><code><span><span class="keyword">val</span> intKindForSize : <span>int <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-ikind">ikind</a></span></code></div><div class="spec-doc"><p>The signed integer kind for a given size (unsigned if second argument is true). Raises Not_found if no such kind exists</p></div></div><div class="odoc-spec"><div class="spec value" id="val-floatKindForSize" class="anchored"><a href="#val-floatKindForSize" class="anchor"></a><code><span><span class="keyword">val</span> floatKindForSize : <span>int <span class="arrow">&#45;&gt;</span></span> <a href="#type-fkind">fkind</a></span></code></div><div class="spec-doc"><p>The float kind for a given size. Raises Not_found if no such kind exists</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bytesSizeOfInt" class="anchored"><a href="#val-bytesSizeOfInt" class="anchor"></a><code><span><span class="keyword">val</span> bytesSizeOfInt : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The size in bytes of the given int kind.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bitsSizeOf" class="anchored"><a href="#val-bitsSizeOf" class="anchor"></a><code><span><span class="keyword">val</span> bitsSizeOf : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The size of a type, in bits. Trailing padding is added for structs and arrays. Raises <a href="#exception-SizeOfError"><code>SizeOfError</code></a> when it cannot compute the size. This function is architecture dependent, so you should only call this after you call <a href="#val-initCIL"><code>initCIL</code></a>. Remember that on GCC sizeof(void) is 1!</p></div></div><div class="odoc-spec"><div class="spec value" id="val-truncateCilint" class="anchored"><a href="#val-truncateCilint" class="anchor"></a><code><span><span class="keyword">val</span> truncateCilint : 
  <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="Cilint/index.html#type-cilint">Cilint.cilint</a> * <a href="Cilint/index.html#type-truncation">Cilint.truncation</a></span></code></div><div class="spec-doc"><p>Represents an integer as for a given kind. Returns a truncation flag saying that the value fit in the kind (NoTruncation), didn't fit but no &quot;interesting&quot; bits (all-0 or all-1) were lost (ValueTruncation) or that bits were lost (BitTruncation). Another way to look at the ValueTruncation result is that if you had used the kind of opposite signedness (e.g. IUInt rather than IInt), you would gave got NoTruncation...</p></div></div><div class="odoc-spec"><div class="spec value" id="val-fitsInInt" class="anchored"><a href="#val-fitsInInt" class="anchor"></a><code><span><span class="keyword">val</span> fitsInInt : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>True if the integer fits within the kind's range</p></div></div><div class="odoc-spec"><div class="spec value" id="val-intKindForValue" class="anchored"><a href="#val-intKindForValue" class="anchor"></a><code><span><span class="keyword">val</span> intKindForValue : <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> <span class="arrow">&#45;&gt;</span></span> <span>bool <span class="arrow">&#45;&gt;</span></span> <a href="#type-ikind">ikind</a></span></code></div><div class="spec-doc"><p>Return the smallest kind that will hold the integer's value. The kind will be unsigned if the 2nd argument is true, signed otherwise. Note that if the value doesn't fit in any of the available types, you will get ILongLong (2nd argument false) or IULongLong (2nd argument true).</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCilint" class="anchored"><a href="#val-mkCilint" class="anchor"></a><code><span><span class="keyword">val</span> mkCilint : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span>int64 <span class="arrow">&#45;&gt;</span></span> <a href="Cilint/index.html#type-cilint">Cilint.cilint</a></span></code></div><div class="spec-doc"><p>Construct a cilint from an integer kind and int64 value. Used for getting the actual constant value from a CInt(n, ik, _) constant.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mkCilintIk" class="anchored"><a href="#val-mkCilintIk" class="anchor"></a><code><span><span class="keyword">val</span> mkCilintIk : <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> <span class="arrow">&#45;&gt;</span></span> <a href="Cilint/index.html#type-cilint">Cilint.cilint</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-const_if_not_overflow" class="anchored"><a href="#val-const_if_not_overflow" class="anchor"></a><code><span><span class="keyword">val</span> const_if_not_overflow : <span><a href="#type-exp">exp</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-ikind">ikind</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="Cilint/index.html#type-cilint">Cilint.cilint</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-sizeOf" class="anchored"><a href="#val-sizeOf" class="anchor"></a><code><span><span class="keyword">val</span> sizeOf : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>The size of a type, in bytes. Returns a constant expression or a &quot;sizeof&quot; expression if it cannot compute the size. This function is architecture dependent, so you should only call this after you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-alignOf_int" class="anchored"><a href="#val-alignOf_int" class="anchor"></a><code><span><span class="keyword">val</span> alignOf_int : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> int</span></code></div><div class="spec-doc"><p>The minimum alignment (in bytes) for a type. This function is architecture dependent, so you should only call this after you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-bitsOffset" class="anchored"><a href="#val-bitsOffset" class="anchor"></a><code><span><span class="keyword">val</span> bitsOffset : <span><a href="#type-typ">typ</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-offset">offset</a> <span class="arrow">&#45;&gt;</span></span> int * int</span></code></div><div class="spec-doc"><p>Give a type of a base and an offset, returns the number of bits from the base address and the width (also expressed in bits) for the subobject denoted by the offset. Raises <a href="#exception-SizeOfError"><code>SizeOfError</code></a> when it cannot compute the size. This function is architecture dependent, so you should only call this after you call <a href="#val-initCIL"><code>initCIL</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-char_is_unsigned" class="anchored"><a href="#val-char_is_unsigned" class="anchor"></a><code><span><span class="keyword">val</span> char_is_unsigned : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether &quot;char&quot; is unsigned. Set after you call <a href="#val-initCIL"><code>initCIL</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-little_endian" class="anchored"><a href="#val-little_endian" class="anchor"></a><code><span><span class="keyword">val</span> little_endian : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether the machine is little endian. Set after you call <a href="#val-initCIL"><code>initCIL</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-underscore_name" class="anchored"><a href="#val-underscore_name" class="anchor"></a><code><span><span class="keyword">val</span> underscore_name : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Whether the compiler generates assembly labels by prepending &quot;_&quot; to the identifier. That is, will function foo() have the label &quot;foo&quot;, or &quot;_foo&quot;? Set after you call <a href="#val-initCIL"><code>initCIL</code></a></p></div></div><div class="odoc-spec"><div class="spec value" id="val-locUnknown" class="anchored"><a href="#val-locUnknown" class="anchor"></a><code><span><span class="keyword">val</span> locUnknown : <a href="#type-location">location</a></span></code></div><div class="spec-doc"><p>Represents a location that cannot be determined</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_instrLoc" class="anchored"><a href="#val-get_instrLoc" class="anchor"></a><code><span><span class="keyword">val</span> get_instrLoc : <span><a href="#type-instr">instr</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-location">location</a></span></code></div><div class="spec-doc"><p>Return the location of an instruction</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_globalLoc" class="anchored"><a href="#val-get_globalLoc" class="anchor"></a><code><span><span class="keyword">val</span> get_globalLoc : <span><a href="#type-global">global</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-location">location</a></span></code></div><div class="spec-doc"><p>Return the location of a global, or locUnknown</p></div></div><div class="odoc-spec"><div class="spec value" id="val-get_stmtLoc" class="anchored"><a href="#val-get_stmtLoc" class="anchor"></a><code><span><span class="keyword">val</span> get_stmtLoc : <span><a href="#type-stmtkind">stmtkind</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-location">location</a></span></code></div><div class="spec-doc"><p>Return the location of a statement, or locUnknown</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dExp" class="anchored"><a href="#val-dExp" class="anchor"></a><code><span><span class="keyword">val</span> dExp : <span><a href="Pretty/index.html#type-doc">Pretty.doc</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-exp">exp</a></span></code></div><div class="spec-doc"><p>Generate an <a href="#type-exp"><code>exp</code></a> to be used in case of errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dInstr" class="anchored"><a href="#val-dInstr" class="anchor"></a><code><span><span class="keyword">val</span> dInstr : <span><a href="Pretty/index.html#type-doc">Pretty.doc</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-instr">instr</a></span></code></div><div class="spec-doc"><p>Generate an <a href="#type-instr"><code>instr</code></a> to be used in case of errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-dGlobal" class="anchored"><a href="#val-dGlobal" class="anchor"></a><code><span><span class="keyword">val</span> dGlobal : <span><a href="Pretty/index.html#type-doc">Pretty.doc</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-location">location</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-global">global</a></span></code></div><div class="spec-doc"><p>Generate a <a href="#type-global"><code>global</code></a> to be used in case of errors.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapNoCopy" class="anchored"><a href="#val-mapNoCopy" class="anchor"></a><code><span><span class="keyword">val</span> mapNoCopy : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span class="type-var">'a</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Like map but try not to make a copy of the list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-mapNoCopyList" class="anchored"><a href="#val-mapNoCopyList" class="anchor"></a><code><span><span class="keyword">val</span> mapNoCopyList : <span><span>( <span><span class="type-var">'a</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span> )</span> <span class="arrow">&#45;&gt;</span></span> <span><span><span class="type-var">'a</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><span class="type-var">'a</span> list</span></span></code></div><div class="spec-doc"><p>Like map but each call can return a list. Try not to make a copy of the list</p></div></div><div class="odoc-spec"><div class="spec value" id="val-startsWith" class="anchored"><a href="#val-startsWith" class="anchor"></a><code><span><span class="keyword">val</span> startsWith : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>sm: return true if the first is a prefix of the second string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-endsWith" class="anchored"><a href="#val-endsWith" class="anchor"></a><code><span><span class="keyword">val</span> endsWith : <span>string <span class="arrow">&#45;&gt;</span></span> <span>string <span class="arrow">&#45;&gt;</span></span> bool</span></code></div><div class="spec-doc"><p>return true if the first is a suffix of the second string</p></div></div><div class="odoc-spec"><div class="spec value" id="val-stripUnderscores" class="anchored"><a href="#val-stripUnderscores" class="anchor"></a><code><span><span class="keyword">val</span> stripUnderscores : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>If string has leading and trailing __, strip them.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-freshLabel" class="anchored"><a href="#val-freshLabel" class="anchor"></a><code><span><span class="keyword">val</span> freshLabel : <span>string <span class="arrow">&#45;&gt;</span></span> string</span></code></div><div class="spec-doc"><p>To generate new labels which do not provoke collision</p></div></div><p><b>An Interpreter for constructing CIL constructs</b></p><div class="odoc-spec"><div class="spec type" id="type-formatArg" class="anchored"><a href="#type-formatArg" class="anchor"></a><code><span><span class="keyword">type</span> formatArg</span><span> = </span></code><table><tr id="type-formatArg.Fe" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fe" class="anchor"></a><code><span>| </span><span><span class="constructor">Fe</span> <span class="keyword">of</span> <a href="#type-exp">exp</a></span></code></td></tr><tr id="type-formatArg.Feo" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Feo" class="anchor"></a><code><span>| </span><span><span class="constructor">Feo</span> <span class="keyword">of</span> <span><a href="#type-exp">exp</a> option</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For array lengths</p><span class="comment-delim">*)</span></td></tr><tr id="type-formatArg.Fu" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fu" class="anchor"></a><code><span>| </span><span><span class="constructor">Fu</span> <span class="keyword">of</span> <a href="#type-unop">unop</a></span></code></td></tr><tr id="type-formatArg.Fb" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fb" class="anchor"></a><code><span>| </span><span><span class="constructor">Fb</span> <span class="keyword">of</span> <a href="#type-binop">binop</a></span></code></td></tr><tr id="type-formatArg.Fk" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fk" class="anchor"></a><code><span>| </span><span><span class="constructor">Fk</span> <span class="keyword">of</span> <a href="#type-ikind">ikind</a></span></code></td></tr><tr id="type-formatArg.FE" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.FE" class="anchor"></a><code><span>| </span><span><span class="constructor">FE</span> <span class="keyword">of</span> <span><a href="#type-exp">exp</a> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For arguments in a function call</p><span class="comment-delim">*)</span></td></tr><tr id="type-formatArg.Ff" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Ff" class="anchor"></a><code><span>| </span><span><span class="constructor">Ff</span> <span class="keyword">of</span> string * <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For a formal argument</p><span class="comment-delim">*)</span></td></tr><tr id="type-formatArg.FF" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.FF" class="anchor"></a><code><span>| </span><span><span class="constructor">FF</span> <span class="keyword">of</span> <span><span>(string * <a href="#type-typ">typ</a> * <a href="#type-attributes">attributes</a>)</span> list</span></span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For formal argument lists</p><span class="comment-delim">*)</span></td></tr><tr id="type-formatArg.Fva" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fva" class="anchor"></a><code><span>| </span><span><span class="constructor">Fva</span> <span class="keyword">of</span> bool</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>For the ellipsis in a function type</p><span class="comment-delim">*)</span></td></tr><tr id="type-formatArg.Fv" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fv" class="anchor"></a><code><span>| </span><span><span class="constructor">Fv</span> <span class="keyword">of</span> <a href="#type-varinfo">varinfo</a></span></code></td></tr><tr id="type-formatArg.Fl" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fl" class="anchor"></a><code><span>| </span><span><span class="constructor">Fl</span> <span class="keyword">of</span> <a href="#type-lval">lval</a></span></code></td></tr><tr id="type-formatArg.Flo" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Flo" class="anchor"></a><code><span>| </span><span><span class="constructor">Flo</span> <span class="keyword">of</span> <span><a href="#type-lval">lval</a> option</span></span></code></td></tr><tr id="type-formatArg.Fo" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fo" class="anchor"></a><code><span>| </span><span><span class="constructor">Fo</span> <span class="keyword">of</span> <a href="#type-offset">offset</a></span></code></td></tr><tr id="type-formatArg.Fc" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fc" class="anchor"></a><code><span>| </span><span><span class="constructor">Fc</span> <span class="keyword">of</span> <a href="#type-compinfo">compinfo</a></span></code></td></tr><tr id="type-formatArg.Fi" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fi" class="anchor"></a><code><span>| </span><span><span class="constructor">Fi</span> <span class="keyword">of</span> <a href="#type-instr">instr</a></span></code></td></tr><tr id="type-formatArg.FI" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.FI" class="anchor"></a><code><span>| </span><span><span class="constructor">FI</span> <span class="keyword">of</span> <span><a href="#type-instr">instr</a> list</span></span></code></td></tr><tr id="type-formatArg.Ft" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Ft" class="anchor"></a><code><span>| </span><span><span class="constructor">Ft</span> <span class="keyword">of</span> <a href="#type-typ">typ</a></span></code></td></tr><tr id="type-formatArg.Fd" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fd" class="anchor"></a><code><span>| </span><span><span class="constructor">Fd</span> <span class="keyword">of</span> int</span></code></td></tr><tr id="type-formatArg.Fg" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fg" class="anchor"></a><code><span>| </span><span><span class="constructor">Fg</span> <span class="keyword">of</span> string</span></code></td></tr><tr id="type-formatArg.Fs" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fs" class="anchor"></a><code><span>| </span><span><span class="constructor">Fs</span> <span class="keyword">of</span> <a href="#type-stmt">stmt</a></span></code></td></tr><tr id="type-formatArg.FS" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.FS" class="anchor"></a><code><span>| </span><span><span class="constructor">FS</span> <span class="keyword">of</span> <span><a href="#type-stmt">stmt</a> list</span></span></code></td></tr><tr id="type-formatArg.FA" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.FA" class="anchor"></a><code><span>| </span><span><span class="constructor">FA</span> <span class="keyword">of</span> <a href="#type-attributes">attributes</a></span></code></td></tr><tr id="type-formatArg.Fp" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.Fp" class="anchor"></a><code><span>| </span><span><span class="constructor">Fp</span> <span class="keyword">of</span> <a href="#type-attrparam">attrparam</a></span></code></td></tr><tr id="type-formatArg.FP" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.FP" class="anchor"></a><code><span>| </span><span><span class="constructor">FP</span> <span class="keyword">of</span> <span><a href="#type-attrparam">attrparam</a> list</span></span></code></td></tr><tr id="type-formatArg.FX" class="anchored"><td class="def variant constructor"><a href="#type-formatArg.FX" class="anchor"></a><code><span>| </span><span><span class="constructor">FX</span> <span class="keyword">of</span> string</span></code></td></tr></table></div><div class="spec-doc"><p>The type of argument for the interpreter</p></div></div><div class="odoc-spec"><div class="spec value" id="val-d_formatarg" class="anchored"><a href="#val-d_formatarg" class="anchor"></a><code><span><span class="keyword">val</span> d_formatarg : <span>unit <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-formatArg">formatArg</a> <span class="arrow">&#45;&gt;</span></span> <a href="Pretty/index.html#type-doc">Pretty.doc</a></span></code></div><div class="spec-doc"><p>Pretty-prints a format arg</p></div></div><div class="odoc-spec"><div class="spec value" id="val-warnTruncate" class="anchored"><a href="#val-warnTruncate" class="anchor"></a><code><span><span class="keyword">val</span> warnTruncate : <span>bool <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Emit warnings when truncating integer constants (default true)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-envMachine" class="anchored"><a href="#val-envMachine" class="anchor"></a><code><span><span class="keyword">val</span> envMachine : <span><span><a href="Machdep/index.html#type-mach">Machdep.mach</a> option</span> <span class="xref-unresolved">Stdlib</span>.ref</span></span></code></div><div class="spec-doc"><p>Machine model specified via CIL_MACHINE environment variable</p></div></div><div class="odoc-spec"><div class="spec value" id="val-gccBuiltins" class="anchored"><a href="#val-gccBuiltins" class="anchor"></a><code><span><span class="keyword">val</span> gccBuiltins : <span><span>( string, <a href="#type-typ">typ</a> * <span><a href="#type-typ">typ</a> list</span> * bool )</span> <span class="xref-unresolved">Stdlib</span>.Hashtbl.t</span></span></code></div><div class="spec-doc"><ul class="at-tags"><li class="deprecated"><span class="at-tag">deprecated</span> <p>. For compatibility with older programs, this is an alias for <code>builtinFunctions</code></p></li></ul></div></div></div><h2 id="cil-modules"><a href="#cil-modules" class="anchor"></a>CIL modules</h2><div class="odoc-spec"><div class="spec module" id="module-Cfg" class="anchored"><a href="#module-Cfg" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cfg/index.html">Cfg</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Code to compute the control-flow graph of a function or file. This will fill in the <code>preds</code> and <code>succs</code> fields of <a href="Cil/index.html#type-stmt"><code>Cil.stmt</code></a></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Check" class="anchored"><a href="#module-Check" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Check/index.html">Check</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Cil" class="anchored"><a href="#module-Cil" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cil/index.html">Cil</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p><b>CIL API Documentation.</b></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Cilint" class="anchored"><a href="#module-Cilint" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cilint/index.html">Cilint</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Cillower" class="anchored"><a href="#module-Cillower" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cillower/index.html">Cillower</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A number of lowering passes over CIL</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Ciltools" class="anchored"><a href="#module-Ciltools" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Ciltools/index.html">Ciltools</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Cilutil" class="anchored"><a href="#module-Cilutil" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cilutil/index.html">Cilutil</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Dataflow" class="anchored"><a href="#module-Dataflow" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Dataflow/index.html">Dataflow</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A framework for data flow analysis for CIL code. Before using this framework, you must initialize the Control-flow Graph for your program, e.g using <a href="Cfg/index.html#val-computeFileCFG"><code>Cfg.computeFileCFG</code></a></p></div></div><div class="odoc-spec"><div class="spec module" id="module-Dominators" class="anchored"><a href="#module-Dominators" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Dominators/index.html">Dominators</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Compute dominators using data flow analysis</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Escape" class="anchored"><a href="#module-Escape" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Escape/index.html">Escape</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Expcompare" class="anchored"><a href="#module-Expcompare" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Expcompare/index.html">Expcompare</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Feature" class="anchored"><a href="#module-Feature" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Feature/index.html">Feature</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Extending CIL with external features</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Formatcil" class="anchored"><a href="#module-Formatcil" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Formatcil/index.html">Formatcil</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>An Interpreter for constructing CIL constructs</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Machdep" class="anchored"><a href="#module-Machdep" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Machdep/index.html">Machdep</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Machdepenv" class="anchored"><a href="#module-Machdepenv" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Machdepenv/index.html">Machdepenv</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Mergecil" class="anchored"><a href="#module-Mergecil" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Mergecil/index.html">Mergecil</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Rmtmps" class="anchored"><a href="#module-Rmtmps" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Rmtmps/index.html">Rmtmps</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="frontc-modules"><a href="#frontc-modules" class="anchor"></a>FrontC modules</h2><div class="odoc-spec"><div class="spec module" id="module-Cabs" class="anchored"><a href="#module-Cabs" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cabs/index.html">Cabs</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>This file was originally part of Hugues Casee's frontc 2.0, and has been extensively changed since. ** ** 1.0 3.22.99 Hugues CassÃ© First version. ** 2.0 George Necula 12/12/00: Many extensions *</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Cabs2cil" class="anchored"><a href="#module-Cabs2cil" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cabs2cil/index.html">Cabs2cil</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Cabshelper" class="anchored"><a href="#module-Cabshelper" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cabshelper/index.html">Cabshelper</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Cabsvisit" class="anchored"><a href="#module-Cabsvisit" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cabsvisit/index.html">Cabsvisit</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Cprint" class="anchored"><a href="#module-Cprint" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cprint/index.html">Cprint</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Frontc" class="anchored"><a href="#module-Frontc" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Frontc/index.html">Frontc</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Patch" class="anchored"><a href="#module-Patch" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Patch/index.html">Patch</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Whitetrack" class="anchored"><a href="#module-Whitetrack" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Whitetrack/index.html">Whitetrack</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><h2 id="utility-modules"><a href="#utility-modules" class="anchor"></a>Utility modules</h2><div class="odoc-spec"><div class="spec module" id="module-Alpha" class="anchored"><a href="#module-Alpha" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Alpha/index.html">Alpha</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>ALPHA conversion</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Errormsg" class="anchored"><a href="#module-Errormsg" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Errormsg/index.html">Errormsg</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Utility functions for error-reporting</p></div></div><div class="odoc-spec"><div class="spec module" id="module-GrowArray" class="anchored"><a href="#module-GrowArray" class="anchor"></a><code><span><span class="keyword">module</span> <a href="GrowArray/index.html">GrowArray</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Array operations.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Inthash" class="anchored"><a href="#module-Inthash" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Inthash/index.html">Inthash</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Pretty" class="anchored"><a href="#module-Pretty" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Pretty/index.html">Pretty</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Utility functions for pretty-printing. The major features provided by this module are</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Stats" class="anchored"><a href="#module-Stats" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Stats/index.html">Stats</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Utilities for maintaining timing statistics</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Trace" class="anchored"><a href="#module-Trace" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Trace/index.html">Trace</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div></div><div class="odoc-spec"><div class="spec module" id="module-Util" class="anchored"><a href="#module-Util" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Util/index.html">Util</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>A bunch of generally useful functions</p></div></div></div></body></html>